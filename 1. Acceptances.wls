#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title::Closed:: *)
(*Just launch the code below to run the notebook (shift+enter)*)


(* ::Input:: *)
(*ClearAll["Global`*"]*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,"Evaluation",All,CellTags];*)
(*SelectionEvaluate[nb]*)


(* ::Title::Closed:: *)
(*Definitions (launch this section first)*)


(* ::Chapter::Closed:: *)
(*Critical definitions required to launch this notebook*)


(* ::Input:: *)
(*SetAttributes[ruleDown,HoldAll];*)
(*ruleDown[list_]:=Flatten[DownValues/@(Unevaluated@list)]*)
(*SetAttributes[ruleOwn,HoldAll];*)
(*ruleOwn[list_]:=Flatten[OwnValues/@(Unevaluated@list)]*)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*choicesDialog[LLP_,spec_List]:=DialogInput[{choice=spec[[All,2,1]]},Column[Flatten@{{LLP},Table[With[{i=i},Column[{TextCell[spec[[i,1]]],PopupMenu[Dynamic[choice[[i]]],spec[[i,-1]]]}]],{i,Length@spec}],Button["OK",DialogReturn[choice]]}]]*)
(*infoDialog[phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],Button["Proceed",DialogReturn[choice]]}]]*)
(*SetOptions[$FrontEnd,"DynamicEvaluationTimeout"->300]*)
(*SetSystemOptions["SimplificationOptions"->"AutosimplifyTrigs"->False]*)
(*<<FeynCalc`*)


(* ::Chapter::Closed:: *)
(*Parameters*)


(* ::Section:: *)
(*Properties of SM particles*)


(* ::Input:: *)
(*(*PDG identifiers of the decay products. Overscript[g, _] is formally introduced as an antiparticle to g, to allow the routine calculating the decay acceptance for experiments without calorimeter decay e.g. S\[Rule]gg*)*)
(*ListSMparticlesSymbols={"\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\[Nu]","\!\(\*OverscriptBox[\(\[Nu]\), \(_\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","\!\(\*SubscriptBox[\(K\), \(L\)]\)","\!\(\*SubscriptBox[\(K\), \(S\)]\)","\!\(\*SuperscriptBox[\(K\), \(+\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)","\[Eta]","\[Gamma]","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","Null","Intermediate","jet","\!\(\*OverscriptBox[\(jet\), \(_\)]\)","g","\!\(\*OverscriptBox[\(g\), \(_\)]\)","s","\!\(\*OverscriptBox[\(s\), \(_\)]\)","c","\!\(\*OverscriptBox[\(c\), \(_\)]\)","b","\!\(\*OverscriptBox[\(b\), \(_\)]\)","u","\!\(\*OverscriptBox[\(u\), \(_\)]\)","d","\!\(\*OverscriptBox[\(d\), \(_\)]\)","\[Omega]","\!\(\*SuperscriptBox[\(K\), \(\(*\)\(+\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(\(*\)\(-\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(\(*\)\(0\)\)]\)","\!\(\*SuperscriptBox[OverscriptBox[\(K\), \(_\)], \(\(*\)\(0\)\)]\)","\[Eta]'","p","\!\(\*OverscriptBox[\(p\), \(_\)]\)","n","\!\(\*OverscriptBox[\(n\), \(_\)]\)","\!\(\*SubscriptBox[\(a\), \(1\)]\)","\[Phi]"};*)
(*ListPDGs={11,-11,12,-12,12,14,16,-12,-14,-16,130,310,321,-321,111,211,-211,113,213,-213,221,22,13,-13,15,-15,999999,-12345678,2,-2,21,-21,3,-3,4,-4,5,-5,2,-2,1,-1,223,323,-323,313,-313,331,2212,-2212,2112,-2112,20113,333}//N;*)
(*MapThread[(ParamProductToPDGid[#1]=#2)&,{ListSMparticlesSymbols,ListPDGs}];*)
(*MapThread[(ParamPDGidToProduct[#1]=#2)&,{ListPDGs,ListSMparticlesSymbols}];*)
(*(*Whether the decay product is stable at the scale of the experiment. Subscript[K, L],K^+,\[Pi]^+,\[Mu]^+ are considered stable*)*)
(*MapThread[(ParamProductStability[#1]=#2)&,{ListPDGs,{1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0}//N}];*)
(*(*Mass of decay product. For jets, their mass is assumed to be te mass of the lightest constituent*)*)
(*MapThread[(ParamProductMass[#1]=#2)&,{ListPDGs,{0.0005,0.0005,0.,0.,0.,0.,0.,0.,0.,0.,0.4976,0.4976,0.4937,0.4937,0.135,0.14,0.14,0.775,0.775,0.775,0.547,0.,0.105,0.105,1.77,1.77,0.,123.,0.135,0.135,0.135,0.135,0.495,0.495,1.87,1.87,5.279,5.279,0.135,0.135,0.135,0.135,0.782,0.892,0.892`,0.892`,0.892,0.958,0.938,0.938,0.939,0.939,1.26,1.02}//N}];*)
(*(*Electric charges of decay products. For jets/gluons, electric charges \[Equal] 1/-1*)*)
(*MapThread[(ParamProductCharge[#1]=#2)&,{ListPDGs,\!\(TraditionalForm\`{\(-1. \), 1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 1. , \(-1. \), 0. , 1. , \(-1. \), 0. , 1. , \(-1. \), 0. , 0. , \(-1. \), 1. , \(-1. \), 1. , 0. , 0. , 1. , \(-1. \), 1. , \(-1. \), 1. , \(-1. \), 1. , \(-1. \), 1. , \(-1. \), 1. , \(-1. \), 1. , \(-1. \), 0. , 1. , \(-1. \), 0. , 0. , 0. , 1. , \(-1. \), 0. , 0. , 0. , 0. }\)//N}];*)
(*Print["Full information about decay products:"]*)
(*Join[{{"Product"},{"PDG ID"},{"Stability"},{"Mass"},{"Electric charge"}},{ListSMparticlesSymbols,ParamProductToPDGid[#]&/@ListSMparticlesSymbols,ParamProductStability[#]&/@(ParamProductToPDGid[#]&/@ListSMparticlesSymbols),ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListSMparticlesSymbols),ParamProductCharge[#]&/@(ParamProductToPDGid[#]&/@ListSMparticlesSymbols)},2]//TableForm*)
(*Print["List of recognizable decay products:"]*)
(*Keys[DownValues@ParamProductToPDGid][[All,1,1]]*)
(*Print["List of PDG ids that may be detected:"]*)
(*detectablepdgs={1.,-1.,2.,-2.,3.,-3.,4.,-4.,5.,-5.,21.,-21.,22.,11.,-11.,13.,-13.,211.,-211.,130.,321.,-321.,2112.,-2112.,2212.,-2212.}//Sort*)


(* ::Chapter::Closed:: *)
(*Kinematics*)


(* ::Section:: *)
(*Lorentz boosts*)


(* ::Input:: *)
(*SetDirectory[NotebookDirectory[]];*)
(*(*Position of the point in coordinate space in terms of spherical coordinates*)*)
(*\[Phi]Val[px_,py_]=If[py>0,ArcCos[px/Sqrt[px^2+py^2]],-ArcCos[px/Sqrt[px^2+py^2]]];*)
(*\[Theta]Val[px_,py_,pz_]=ArcCos[pz/(\[Sqrt](px^2+py^2+pz^2))];*)
(*(*Decaying particle momentum and velocity at its lab frame. Since the experiment geometry is convenient to characterize in terms of spherical coordinates, it is given here in both spherical and cartesian coordinates*)*)
(*pMotherVecCart[px_,py_,pz_]={px,py,pz};*)
(*vMotherVecCart[Ev_,px_,py_,pz_]=+(pMotherVecCart[px,py,pz]/Ev);*)
(*(*\[Gamma],\[CapitalGamma] factors*)*)
(*\[Gamma]Factor[ELLP_,mLLP_]=ELLP/mLLP;*)
(*\[CapitalGamma]factor[ELLP_,mLLP_]=Simplify[(\[Gamma]Factor[ELLP,mLLP]-1)/((v/.Solve[\[Gamma]Factor[ELLP,mLLP]==1/Sqrt[1-v^2],v])^2)[[1]]];*)
(*pprod={pxd,pyd,pzd};*)
(*vmotherlab=vMotherVecCart[Em,pxm,pym,pzm];*)
(*pproductLabVecCart[pxm_,pym_,pzm_,Em_,mm_,pxd_,pyd_,pzd_,Ed_]=Simplify[pprod+\[Gamma]Factor[Em,mm]*vmotherlab*Ed+\[CapitalGamma]factor[Em,mm]*vmotherlab(vmotherlab . pprod)];*)
(*EproductLabCart[pxm_,pym_,pzm_,Em_,mm_,pxd_,pyd_,pzd_,Ed_]=Simplify[\[Gamma]Factor[Em,mm](Ed+vmotherlab . pprod)];*)
(*{pproductLab1Cart[pxm_,pym_,pzm_,Em_,mm_,pxd_,pyd_,pzd_,Ed_],pproductLab2Cart[pxm_,pym_,pzm_,Em_,mm_,pxd_,pyd_,pzd_,Ed_],pproductLab3Cart[pxm_,pym_,pzm_,Em_,mm_,pxd_,pyd_,pzd_,Ed_]}=Simplify[pproductLabVecCart[pxm,pym,pzm,Em,mm,pxd,pyd,pzd,Ed][[#]]]&/@{1,2,3};*)
(*Print["Check that \!\(\*SubscriptBox[SuperscriptBox[\(E\), \(2\)], \(boosted\)]\) - \!\(\*SubscriptBox[SuperscriptBox[OverscriptBox[\(p\), \(_\)], \(2\)], \(boosted\)]\) = \!\(\*SuperscriptBox[\(m\), \(2\)]\):"]*)
(*testExpr[pxm_,pym_,pzm_,Em_,mm_,pxd_,pyd_,pzd_,Ed_]=((EproductLabCart[pxm,pym,pzm,Em,mm,pxd,pyd,pzd,Ed]^2-pproductLab1Cart[pxm,pym,pzm,Em,mm,pxd,pyd,pzd,Ed]^2-pproductLab2Cart[pxm,pym,pzm,Em,mm,pxd,pyd,pzd,Ed]^2-pproductLab3Cart[pxm,pym,pzm,Em,mm,pxd,pyd,pzd,Ed]^2//Expand//Simplify)/.{pxm^2->Em^2-pym^2-pzm^2-mm^2}//Expand//Simplify)/.{Em^2->pxm^2+pym^2+pzm^2+mm^2};*)
(*testExpr[pxm,pym,pzm,Sqrt[pxm^2+pym^2+pzm^2+mm^2],mm,Sqrt[Ed^2-pyd^2-pzd^2-m^2],pyd,pzd,Ed]//Simplify*)
(*(*The same but assuming that the mother 3-momentum is given in terms of spherical coordinates*)*)
(*pMotherVecSpher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_]=Sqrt[ELLP^2-mLLP^2]{Sin[\[Theta]LLP]*Cos[\[Phi]LLP],Sin[\[Theta]LLP]*Sin[\[Phi]LLP],Cos[\[Theta]LLP]};*)
(*vMotherVecSpher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_]=+(pMotherVecSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP]/ELLP);*)
(*pproductLabVecSpher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_,pxd_,pyd_,pzd_,Ed_]=Simplify[pprod+\[Gamma]Factor[ELLP,mLLP]*vMotherVecSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP]*Ed+\[CapitalGamma]factor[ELLP,mLLP]*vMotherVecSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP](vMotherVecSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP] . pprod)];*)
(*EproductLabSpher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_,pxd_,pyd_,pzd_,Ed_]=Simplify[\[Gamma]Factor[ELLP,mLLP](Ed+vMotherVecSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP] . pprod)];*)
(*{pproductLab1Spher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_,pxd_,pyd_,pzd_,Ed_],pproductLab2Spher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_,pxd_,pyd_,pzd_,Ed_],pproductLab3Spher[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_,pxd_,pyd_,pzd_,Ed_]}=Simplify[pproductLabVecSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP,pxd,pyd,pzd,Ed][[#]]&/@{1,2,3}];*)
(*Print["Check that \!\(\*SubscriptBox[SuperscriptBox[\(E\), \(2\)], \(boosted\)]\) - \!\(\*SubscriptBox[SuperscriptBox[OverscriptBox[\(p\), \(_\)], \(2\)], \(boosted\)]\) = \!\(\*SuperscriptBox[\(m\), \(2\)]\) - for the formulas expressed in spherical LLP coordinates:"]*)
(*testExpr2[ELLP_,mLLP_,\[Theta]LLP_,\[Phi]LLP_,pxd_,pyd_,pzd_,Ed_]=EproductLabSpher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP,pxd,pyd,pzd,Ed]^2-pproductLab1Spher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP,pxd,pyd,pzd,Ed]^2-pproductLab2Spher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP,pxd,pyd,pzd,Ed]^2-pproductLab3Spher[ELLP,mLLP,\[Theta]LLP,\[Phi]LLP,pxd,pyd,pzd,Ed]^2//Expand//Simplify*)


(* ::Section:: *)
(*Kinematics of 3-body decays*)


(* ::Subsection:: *)
(*Phase space in terms of energies Subscript[E, 1],Subscript[E, 3]*)


(* ::Input:: *)
(*(*Kinematics of 3-body decays*)*)
(*pPar[En_,mn_]=Sqrt[En^2-mn^2];*)
(*E2valEnergies[m_,E1_,E3_]=m-E1-E3;*)
(*(*Rotation matrices with around z axis (\[Phi] angle) and x axis (\[Theta] angle)*)*)
(*\[Phi]RotMatrix[\[Phi]_]={{Cos[\[Phi]],Sin[\[Phi]],0},{-Sin[\[Phi]],Cos[\[Phi]],0},{0,0,1}};*)
(*\[Theta]RotMatrix[\[Theta]_]={{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};*)
(*(*cos between particles 1,2 and 1,3 at rest frame of decaying particle 0 \[Rule] 1+2+3 parametrized in terms of Subscript[E, 1],Subscript[E, 3]*)*)
(**)
(*cos\[Theta]12[E1_,E3_,m_,m1_,m2_,m3_]=(pPar[E3,m3]^2-pPar[E1,m1]^2-pPar[E2valEnergies[m,E1,E3],m2]^2)/(2pPar[E1,m1]*pPar[E2valEnergies[m,E1,E3],m2]);*)
(*cos\[Theta]13[E1_,E3_,m_,m1_,m2_,m3_]=(pPar[E2valEnergies[m,E1,E3],m2]^2-pPar[E1,m1]^2-pPar[E3,m3]^2)/(2pPar[E1,m1]*pPar[E3,m3]);*)
(*\[Theta]12[E1_,E3_,m_,m1_,m2_,m3_]=ArcCos[cos\[Theta]12[E1,E3,m,m1,m2,m3]];*)
(*\[Theta]13[E1_,E3_,m_,m1_,m2_,m3_]=ArcCos[cos\[Theta]13[E1,E3,m,m1,m2,m3]];*)
(*(*Values of \[Theta]12,\[Theta]13 - compiled (for faster code)*)*)
(*\[Theta]12comp=Compile[{E1,E3,m,m1,m2,m3},(*ArcCos[cos\[Theta]12[E1,E3,m,m1,m2,m3]]*)\[Theta]12[E1,E3,m,m1,m2,m3]];*)
(*\[Theta]13comp=Compile[{E1,E3,m,m1,m2,m3},(*ArcCos[cos\[Theta]13[E1,E3,m,m1,m2,m3]]*)\[Theta]13[E1,E3,m,m1,m2,m3]];*)
(*(*Domain of definition of Subscript[E, 1] and Subscript[E, 3] in decay 0\[Rule]1+2+3 at rest frame of 0, Subscript[E, 3,min/max] = f(Subscript[E, 1])*)*)
(*E3domain[E1_,m_,m1_,m2_,m3_]=E3/.(*Assuming[m>0&&E1>m1>0,*)Simplify[Solve[cos\[Theta]12[E1,E3,m,m1,m2,m3]==1,E3]](*]*)*)
(*E3domainMin[E1_,m_,m1_,m2_,m3_]=E3domain[E1,m,m1,m2,m3][[1]];*)
(*E3domainMax[E1_,m_,m1_,m2_,m3_]=E3domain[E1,m,m1,m2,m3][[2]];*)
(*\[CapitalDelta]E3[E1_,m_,m1_,m2_,m3_]=E3domainMax[E1,m,m1,m2,m3]-E3domainMin[E1,m,m1,m2,m3]//Simplify*)
(*{E1domainMin[m_,m1_,m2_,m3_],E1domainMax[m_,m1_,m2_,m3_]}=E1domain[m_,m1_,m2_,m3_]={E1/.Solve[\[CapitalDelta]E3[E1,m,m1,m2,m3][[2]]==0,E1][[2]],E1/.Solve[\[CapitalDelta]E3[E1,m,m1,m2,m3][[2]]==0,E1][[3]]}//Simplify*)
(*(*Domain of definition of Subscript[E, 1] and Subscript[E, 3] in decay 0\[Rule]1+2+3 at rest frame of 0, now Subscript[E, 1,min/max] = f(Subscript[E, 3])*)*)
(*E1domain1[E1_,m_,m1_,m2_,m3_]=E1/.(*Assuming[m>0&&E1>m1>0,*)Simplify[Solve[cos\[Theta]12[E1,E3,m,m1,m2,m3]==1,E1]](*]*);*)
(*E1domain1Min[E1_,m_,m1_,m2_,m3_]=E1domain1[E3,m,m1,m2,m3][[1]];*)
(*E1domain1Max[E1_,m_,m1_,m2_,m3_]=E1domain1[E3,m,m1,m2,m3][[2]];*)
(*\[CapitalDelta]E1[E3_,m_,m1_,m2_,m3_]=E1domain1Max[E3,m,m1,m2,m3]-E1domain1Min[E3,m,m1,m2,m3]//Simplify;*)
(*{E3domain1Min[m_,m1_,m2_,m3_],E3domain1Max[m_,m1_,m2_,m3_]}=E3domain1[m_,m1_,m2_,m3_]={E3/.Solve[\[CapitalDelta]E1[E3,m,m1,m2,m3][[2]]==0,E3][[2]],E3/.Solve[\[CapitalDelta]E1[E3,m,m1,m2,m3][[2]]==0,E3][[3]]}//Simplify;*)
(*(*Mandelstam invariants in terms of energies*)*)
(*M13[E1_,E3_]=(E1+E3)^2-(pPar[E1,m1]^2+pPar[E3,m3]^2+2*pPar[E1,m1]*pPar[E3,m3]*cos\[Theta]13[E1,E3,m,m1,m2,m3])//Expand//Simplify*)
(*M12[E1_,E3_]=(E1+E2valEnergies[m,E1,E3])^2-(pPar[E1,m1]^2+pPar[E2valEnergies[m,E1,E3],m2]^2+2*pPar[E1,m1]*pPar[E2valEnergies[m,E1,E3],m2]*cos\[Theta]12[E1,E3,m,m1,m2,m3])//Expand//Simplify*)
(*Q2[E1_,E3_,m_,m2_]=(m^2+m2^2-2*m*E2valEnergies[m,E1,E3]);*)
(*(*Rotation matrices with around z axis (\[Phi] angle) and x axis (\[Theta] angle)*)*)
(*\[Phi]RotMatrix[\[Phi]_]={{Cos[\[Phi]],Sin[\[Phi]],0},{-Sin[\[Phi]],Cos[\[Phi]],0},{0,0,1}};*)
(*\[Theta]RotMatrix[\[Theta]_]={{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};*)
(*(*Domain of the parameter space E1,E3 for Subscript[E, 1] ranging between Subscript[E, min],Subscript[E, max]*)*)
(*E12E23domain[m_,m1_,m2_,m3_,Emin_,Emax_]:=NIntegrate[UnitStep[E3v-Emin]*UnitStep[Emax-E3v],{E1v,E1domain[m,m1,m2,m3][[1]],E1domain[m,m1,m2,m3][[2]]},{E3v,Max[E3domain[E1v,m,m1,m2,m3][[1]],Emin],Min[Emax,E3domain[E1v,m,m1,m2,m3][[2]]]},Method->"AdaptiveMonteCarlo"]*)


(* ::Subsubsection:: *)
(*Scalar products in terms of energies 1,3*)


(* ::Input:: *)
(*ProductKK=m^2;*)
(*ProductK2K2=m2^2;*)
(*ProductK3K3=m3^2;*)
(*ProductK1K1=m1^2;*)
(*ProductKK2energy=m*E2valEnergies[m,E1,E3];*)
(*ProductKK1energy=m*E1;*)
(*ProductKK3energy=m*E3;*)
(*ProductK1K3energy=(M13[E1,E3]-m1^2-m3^2)/2;*)
(*ProductK1K2energy=(M12[E1,E3]-m1^2-m2^2)/2;*)
(*ProductK2K3energy=(m^2+m1^2-2*m*E1-m2^2-m3^2)/2;*)


(* ::Subsubsection:: *)
(*Scalar products in terms of Mandelstam variables*)


(* ::Input:: *)
(*ProductKK1mandelstam=(m^2+m1^2-m23)/2;*)
(*ProductKK3mandelstam=(m^2+m3^2-m12)/2;*)
(*ProductKK2mandelstam=(m^2-ProductKK1mandelstam-ProductKK3mandelstam)//Simplify;*)
(*ProductK1K2mandelstam=(m12-m1^2-m2^2)/2;*)
(*ProductK2K3mandelstam=(m23-m2^2-m3^2)/2;*)
(*ProductK1K3mandelstam=(m^2-2ProductKK2mandelstam+m2^2-m1^2-m3^2)/2//Simplify;*)
(*ScalarProduct3body[1,2]=ProductK1K2mandelstam;*)
(*ScalarProduct3body[2,3]=ProductK2K3mandelstam;*)
(*ScalarProduct3body[1,3]=ProductK1K3mandelstam;*)
(*ScalarProduct3body[1,1]=m1^2;*)
(*ScalarProduct3body[2,2]=m2^2;*)
(*ScalarProduct3body[3,3]=m3^2;*)
(*ProductKK-ProductK1K1-ProductK2K2-ProductK3K3-2*(ProductK1K2mandelstam+ProductK2K3mandelstam+ProductK1K3mandelstam)//Simplify*)


(* ::Subsubsection:: *)
(*4-momenta of decay products at rest frame as a function of energies Subscript[E, 1],Subscript[E, 3]*)


(* ::Input:: *)
(*(*Rotation matrices with around z axis (\[Phi] angle) and x axis (\[Theta] angle)*)*)
(*\[Phi]RotMatrix[\[Phi]_]={{Cos[\[Phi]],Sin[\[Phi]],0},{-Sin[\[Phi]],Cos[\[Phi]],0},{0,0,1}};*)
(*\[Theta]RotMatrix[\[Theta]_]={{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};*)
(*pvecUnrotated[px_,py_,pz_]={px,py,pz};*)
(*pvecRotated[px_,py_,pz_,\[Theta]V_,\[Phi]V_]=\[Phi]RotMatrix[\[Phi]V] . \[Theta]RotMatrix[\[Theta]V] . pvecUnrotated[px,py,pz];*)
(*(*Momenta at frame where Subscript[p, 1] is aligned along z axis*)*)
(*p1unrotated={0,0,pPar[E1,m1]};*)
(*p2unrotated={pPar[E2valEnergies[m,E1,E3],m2]*Sin[\[Theta]12[E1,E3,m,m1,m2,m3]]*Sin[\[Kappa]],pPar[E2valEnergies[m,E1,E3],m2]*Sin[\[Theta]12[E1,E3,m,m1,m2,m3]]*Cos[\[Kappa]],pPar[E2valEnergies[m,E1,E3],m2]*Cos[\[Theta]12[E1,E3,m,m1,m2,m3]]};*)
(*p3unrotated={-pPar[E3,m3]*Sin[\[Theta]13[E1,E3,m,m1,m2,m3]]*Sin[\[Kappa]],-pPar[E3,m3]*Sin[\[Theta]13[E1,E3,m,m1,m2,m3]]*Cos[\[Kappa]],pPar[E3,m3]*Cos[\[Theta]13[E1,E3,m,m1,m2,m3]]};*)
(*(*\[Theta]rand=RandomReal[{0,Pi}];*)
(*\[Phi]rand=RandomReal[{-Pi,Pi}];*)*)
(*p1rotated[E1_,m1_,\[Theta]V_,\[Phi]V_]=(*\[Phi]RotMatrix[\[Phi]V].\[Theta]RotMatrix[\[Theta]V].p1Unrotated*)pvecRotated[p1unrotated[[1]],p1unrotated[[2]],p1unrotated[[3]],\[Theta]V,\[Phi]V];*)
(*p1rotatedX[E1_,m1_,\[Theta]V_,\[Phi]V_]=p1rotated[E1,m1,\[Theta]V,\[Phi]V][[1]];*)
(*p1rotatedY[E1_,m1_,\[Theta]V_,\[Phi]V_]=p1rotated[E1,m1,\[Theta]V,\[Phi]V][[2]];*)
(*p1rotatedZ[E1_,m1_,\[Theta]V_,\[Phi]V_]=p1rotated[E1,m1,\[Theta]V,\[Phi]V][[3]];*)
(*p2rotated[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=pvecRotated[p2unrotated[[1]],p2unrotated[[2]],p2unrotated[[3]],\[Theta]V,\[Phi]V]//Simplify;*)
(*p2rotatedX[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=p2rotated[E1,E3,m,m1,m2,m3,\[Theta]V,\[Phi]V,\[Kappa]][[1]];*)
(*p2rotatedY[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=p2rotated[E1,E3,m,m1,m2,m3,\[Theta]V,\[Phi]V,\[Kappa]][[2]];*)
(*p2rotatedZ[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=p2rotated[E1,E3,m,m1,m2,m3,\[Theta]V,\[Phi]V,\[Kappa]][[3]];*)
(*p3rotated[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=pvecRotated[p3unrotated[[1]],p3unrotated[[2]],p3unrotated[[3]],\[Theta]V,\[Phi]V]//Simplify;*)
(*p3rotatedX[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=p3rotated[E1,E3,m,m1,m2,m3,\[Theta]V,\[Phi]V,\[Kappa]][[1]];*)
(*p3rotatedY[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=p3rotated[E1,E3,m,m1,m2,m3,\[Theta]V,\[Phi]V,\[Kappa]][[2]];*)
(*p3rotatedZ[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]=p3rotated[E1,E3,m,m1,m2,m3,\[Theta]V,\[Phi]V,\[Kappa]][[3]];*)


(* ::Chapter::Closed:: *)
(*Decays of various LLPs: processes, branching ratios, matrix elements*)


(* ::Section:: *)
(*Definitions*)


(* ::Input:: *)
(*procList[LLP_]:=Select[Keys[DownValues@ListBrRatiosTemp][[All,1,#]]&/@{1,3}//Transpose,#[[1]]==LLP&][[All,2]]*)
(*procListnoecal[LLP_]:=Block[{},*)
(*prl=procList[LLP];*)
(*(*For the list of final states for the given decays, select only charged*)*)
(*chargedprods=Table[{prl[[i]],Select[ListDecayProducts[LLP,prl[[i]]],MemberQ[{"\[Gamma]","\!\(\*SubscriptBox[\(K\), \(L\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","\[Nu]","\!\(\*OverscriptBox[\(\[Nu]\), \(_\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)"},#]==False&]},{i,1,Length[prl],1}];*)
(*Select[chargedprods,#[[2]]!={}&][[All,1]]*)
(*]*)


(* ::Section:: *)
(*Scalar*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*(*Branching ratios*)*)
(*LLPsel="Scalar";*)
(*BrRatiosTableTemp=Select[Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/BrRatios.m"}],"MX"],#[[1]]!=2&];*)
(*Join[{Table[i,{i,1,Length[BrRatiosTableTemp[[1]]],1}]},{BrRatiosTableTemp[[1]]}]//TableForm*)
(*BrRatiosTable=Drop[BrRatiosTableTemp,1];*)
(*BrRatioScalar[mLLP_,i_]:=Interpolation[BrRatiosTable[[All,{1,i}]],InterpolationOrder->1][mLLP];*)
(*proc="e-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={BrRatioScalar[mLLP,2],{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","Null","Null"},"No"};*)
(*proc="\[Mu]-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={BrRatioScalar[mLLP,3],{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","Null","Null"},"No"};*)
(*proc="\[Tau]-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={BrRatioScalar[mLLP,8],{"\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","Null","Null"},"No"};*)
(*(*Uncomment the pieces of code below if you want to compare with SensMC*)*)
(*proc="\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={1/3 BrRatioScalar[mLLP,4](*+(1/3)BrRatioScalar[mLLP,6]*),{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","Null"},"No"};*)
(*proc="\!\(\*SuperscriptBox[\(\[Pi]\), \(charged\)]\)-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={2/3 BrRatioScalar[mLLP,4](*+(2/3)BrRatioScalar[mLLP,6]*),{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},"No"};*)
(*(*Comment the two strings below if you want to compare with SensMC*)*)
(*proc="4\[Pi]";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={BrRatioScalar[mLLP,6],{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"},"No"};*)
(*proc="\!\(\*SuperscriptBox[\(K\), \(charged\)]\)-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[mLLP<=2,Evaluate[1/2 BrRatioScalar[mLLP,5]],0],{"\!\(\*SuperscriptBox[\(K\), \(+\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)","Null","Null"} ,"No"};*)
(*proc="KS-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[mLLP<=2,Evaluate[1/8 BrRatioScalar[mLLP,5]],0],{"\!\(\*SubscriptBox[\(K\), \(S\)]\)","\!\(\*SubscriptBox[\(K\), \(S\)]\)","Null","Null"},"No"};*)
(*proc="KL-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[mLLP<=2,Evaluate[1/8 BrRatioScalar[mLLP,5]],0],{"\!\(\*SubscriptBox[\(K\), \(L\)]\)","\!\(\*SubscriptBox[\(K\), \(L\)]\)","Null","Null"},"No"};*)
(*proc="KLKS-pair";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[mLLP<=2,Evaluate[1/4 BrRatioScalar[mLLP,5]],0], {"\!\(\*SubscriptBox[\(K\), \(L\)]\)","\!\(\*SubscriptBox[\(K\), \(S\)]\)","Null","Null"},"No"};*)
(*proc="Jets-ss";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[2<mLLP<=3.8,Evaluate[BrRatioScalar[mLLP,5]],0], {"s","\!\(\*OverscriptBox[\(s\), \(_\)]\)","Null","Null"},"Yes"};*)
(*proc="Jets-cc";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[mLLP<17,Evaluate[BrRatioScalar[mLLP,9]],0], {"c","\!\(\*OverscriptBox[\(c\), \(_\)]\)","Null","Null"},"Yes"};*)
(*proc="Jets-GG";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={If[mLLP<5,Evaluate[BrRatioScalar[mLLP,7]],0], {"g","\!\(\*OverscriptBox[\(g\), \(_\)]\)","Null","Null"},"Yes"};*)
(*proc="Jets-bb";*)
(*{ListBrRatiosTemp[LLPsel,mLLP_,proc],ListDecayProducts[LLPsel,proc],JetsPresence[LLPsel,proc]}={Evaluate[BrRatioScalar[mLLP,10]], {"b","\!\(\*OverscriptBox[\(b\), \(_\)]\)","Null","Null"},"Yes"};*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]=procList[LLPsel];*)
(*Table[{ProcessesList[LLPsel,"True"][[i]],ListDecayProducts[LLPsel,ProcessesList[LLPsel,"True"][[i]]]},{i,1,Length[ProcessesList[LLPsel,"True"]],1}]//Transpose//TableForm*)
(*(*The total br ratio must be one. However, due to some missing unimportant channels and some approximations, it is typically slightly smaller. Therefore, the br ratios are refined to be normalized by 1*)*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Section:: *)
(*DP*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="DP";*)
(*BrRatiosDPdata[mV_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/BrRatios.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=BrRatiosDPdata[mV][[1]];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosDPdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosDPdata[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-light","Jets-cc"},procsel],"Yes","No"]*)
(*,{i,1,Length[BrRatiosDPdata[mLLP][[1]]],1}]*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*Table[{ProcessesList[LLPsel,"True"][[i]],ListDecayProducts[LLPsel,ProcessesList[LLPsel,"True"][[i]]]},{i,1,Length[ProcessesList[LLPsel,"True"]],1}]//Transpose//TableForm*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Input:: *)
(*Msquared3BodyLLP["DP","KK\[Pi]",E1_,E3_,mFIP_]=Msquared3BodyLLP["DP","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1_,E3_,mFIP_]=1;*)


(* ::Section:: *)
(*HNL*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*HNLsList={"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau"};*)


(* ::Subsubsection:: *)
(*Mixing e*)


(* ::Input:: *)
(*BrRatiosHNLdata[mN_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology/HNL/decay widths/BrExclusiveMixinge.m"}],"MX"];*)
(*LLPsel=HNLsList[[1]];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosHNLdata[mV][[1]],-1];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosHNLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosHNLdata[mN][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-qql","Jets-qqv"},procsel],"Yes","No"]*)
(*,{i,1,Length[BrRatiosHNLdata[mLLP][[1]]]-1,1}]*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*Table[{ProcessesList[LLPsel,"True"][[i]],ListDecayProducts[LLPsel,ProcessesList[LLPsel,"True"][[i]]]},{i,1,Length[ProcessesList[LLPsel,"True"]],1}]//Transpose//TableForm*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+BrRatiosHNLdata[mLLP][[3]][[-1]])*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,40},PlotRange->All]*)


(* ::Subsubsection:: *)
(*Mixing \[Mu]*)


(* ::Input:: *)
(*BrRatiosHNLdata[mN_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology/HNL/decay widths/BrExclusiveMixing\[Mu].m"}],"MX"];*)
(*LLPsel=HNLsList[[2]];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosHNLdata[mN][[1]],-1];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosHNLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosHNLdata[mN][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-qql","Jets-qqv"},procsel],"Yes","No"]*)
(*,{i,1,Length[BrRatiosHNLdata[mLLP][[1]]]-1,1}]*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*Table[{ProcessesList[LLPsel,"True"][[i]],ListDecayProducts[LLPsel,ProcessesList[LLPsel,"True"][[i]]]},{i,1,Length[ProcessesList[LLPsel,"True"]],1}]//Transpose//TableForm*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+BrRatiosHNLdata[mLLP][[3]][[-1]])*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,20},PlotRange->All]*)


(* ::Subsubsection:: *)
(*Mixing \[Tau]*)


(* ::Input:: *)
(*BrRatiosHNLdata[mN_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology/HNL/decay widths/BrExclusiveMixing\[Tau].m"}],"MX"];*)
(*LLPsel=HNLsList[[3]];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosHNLdata[mV][[1]],-1];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosHNLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosHNLdata[mN][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-qql","Jets-qqv"},procsel],"Yes","No"]*)
(*,{i,1,Length[BrRatiosHNLdata[mLLP][[1]]]-1,1}]*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*Table[{ProcessesList[LLPsel,"True"][[i]],ListDecayProducts[LLPsel,ProcessesList[LLPsel,"True"][[i]]]},{i,1,Length[ProcessesList[LLPsel,"True"]],1}]//Transpose//TableForm*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+BrRatiosHNLdata[mLLP][[3]][[-1]])*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,20},PlotRange->All]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Subsubsection:: *)
(*N->\[Pi]\[Pi]\[Nu]/\[Pi]\[Pi]l*)


(* ::Input:: *)
(*MNtol\[Pi]\[Pi]=1/Sqrt[2] SpinorUBar[p3,m3] . GA[\[Mu]] . (1-GA[5]) . SpinorU[p,m]*(-MT[\[Mu],\[Nu]]+(FV[p-p3,\[Mu]]*FV[p-p3,\[Nu]])/m\[Rho]^2)/Sqrt[(ExpandScalarProduct[ScalarProduct[p-p3,p-p3]]-m\[Rho]^2)^2+\[CapitalGamma]\[Rho]^2*m\[Rho]^2]*(FV[p2-p1,\[Nu]])//Contract//ExpandScalarProduct;*)
(*MNtol\[Pi]\[Pi]Star=ComplexConjugate[MNtol\[Pi]\[Pi]];*)
(*MNtol\[Pi]\[Pi]SquaredTemp=1/2 FermionSpinSum[MNtol\[Pi]\[Pi]*MNtol\[Pi]\[Pi]Star]/.DiracTrace->TR//Contract//Simplify//ExpandScalarProduct;*)
(*MNtol\[Pi]\[Pi]SquaredTemp2[E1_,E3_,m_,m1_,m2_,m3_]=(MNtol\[Pi]\[Pi]SquaredTemp/.{ScalarProduct[p,p1]->ProductKK1energy,ScalarProduct[p,p2]->ProductKK2energy,ScalarProduct[p1,p2]->ProductK1K2energy,ScalarProduct[p,p]->ProductKK,ScalarProduct[p,p3]->ProductKK3energy,ScalarProduct[p2,p2]->ProductK2K2,ScalarProduct[p3,p3]->ProductK3K3,ScalarProduct[p2,p3]->ProductK2K3energy,ScalarProduct[p1,p3]->ProductK1K3energy,ScalarProduct[p1,p1]->ProductK1K1}//Expand//Simplify)/.{\[CapitalGamma]\[Rho]->0.1478,m\[Rho]->ParamProductMass[113.]};*)
(*Do[*)
(*fip=LLP;*)
(*proc=PROC;*)
(*mprodlist=ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListDecayProducts[fip,proc]);*)
(*Msquared3BodyLLP[fip,proc,E1_,E3_,mLLP_]=MNtol\[Pi]\[Pi]SquaredTemp2[E1,E3,mLLP,m1,m2,m3]/.Table[Symbol["m"<>ToString[i]]->mprodlist[[i]],{i,1,3,1}]//Simplify*)
(*,{PROC,{"2\[Pi]l","2\[Pi]\[Nu]"}},{LLP,HNLsList}]*)


(* ::Subsubsection:: *)
(*N-> q+\!\(\*OverscriptBox[\(q\), \(_\)]\)'+l, q+\!\(\*OverscriptBox[\(q\), \(_\)]\)+\[Nu] *)


(* ::Input:: *)
(*(*____________________________________________________*)*)
(*(*qq\[VeryThinSpace]l*)*)
(*(*____________________________________________________*)*)
(*M3bodyqql=1/(2Sqrt[2]) SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]*SpinorUBar[k1,m1] . GA[\[Mu]] . (1-GA5) . SpinorV[k2,m2]//Contract;*)
(*M3bodyqqlStar=ComplexConjugate[M3bodyqql];*)
(*M3bodyqqlSquared[E1_,E3_,m_,m1_,m2_,m3_]=Simplify[Expand[FermionSpinSum[M3bodyqql M3bodyqqlStar]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k,k2]->ProductKK2energy,ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k3]->ProductK1K3energy ,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k2,k3]-> ProductK2K3energy}//Simplify*)
(*Do[*)
(*fip=LLP;*)
(*proc="Jets-qql";*)
(*mprodlist=ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListDecayProducts[fip,proc]);*)
(*Msquared3BodyLLP[fip,proc,E1_,E3_,mLLP_]=M3bodyqqlSquared[E1,E3,mLLP,m1,m2,m3]/.Table[Symbol["m"<>ToString[i]]->mprodlist[[i]],{i,1,3,1}]//Chop//Simplify*)
(*,{LLP,HNLsList}]*)
(*(*____________________________________________________*)*)
(*(*qq\[VeryThinSpace]\[Nu], assuming that the main contribution comes from u/d quarks*)*)
(*(*____________________________________________________*)*)
(*M3bodyqq\[Nu]=1/2*1/(4Sqrt[2]) (SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]*SpinorUBar[k1,m1] . GA[\[Mu]] . (1-4/3 sin2\[Theta]w-GA5) . SpinorV[k2,m2]+SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]*SpinorUBar[k1,m1] . GA[\[Mu]] . (1+8/3 sin2\[Theta]w-GA5) . SpinorV[k2,m2])//Contract;*)
(*M3bodyqq\[Nu]Star=ComplexConjugate[M3bodyqq\[Nu]];*)
(*M3bodyqq\[Nu]Squared[E1_,E3_,m_,m1_,m2_,m3_]=Simplify[Expand[FermionSpinSum[M3bodyqq\[Nu] M3bodyqq\[Nu]Star]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k,k2]->ProductKK2energy,ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k3]->ProductK1K3energy ,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k2,k3]-> ProductK2K3energy}//Simplify*)
(*Do[*)
(*fip=LLP;*)
(*proc="Jets-qqv";*)
(*mprodlist=ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListDecayProducts[fip,proc]);*)
(*Msquared3BodyLLP[fip,proc,E1_,E3_,mLLP_]=M3bodyqq\[Nu]Squared[E1,E3,mLLP,m1,m2,m3]/.Table[Symbol["m"<>ToString[i]]->mprodlist[[i]],{i,1,3,1}]/.{sin2\[Theta]w->0.23}//Chop//Simplify*)
(*,{LLP,HNLsList}]*)


(* ::Subsubsection:: *)
(*N->l+l'+\[Nu]*)


(* ::Input:: *)
(*procsleptonic[HNLsList[[3]]]={"\[Tau]e\[Nu]","\[Tau]\[Mu]\[Nu]","ee\[Nu]","\[Mu]\[Mu]\[Nu]","\[Tau]\[Tau]\[Nu]"};*)
(*procsleptonic[HNLsList[[2]]]={"\[Mu]e\[Nu]","\[Mu]\[Tau]\[Nu]","ee\[Nu]","\[Mu]\[Mu]\[Nu]","\[Tau]\[Tau]\[Nu]"};*)
(*procsleptonic[HNLsList[[1]]]={"e\[Mu]\[Nu]","e\[Tau]\[Nu]","ee\[Nu]","\[Mu]\[Mu]\[Nu]","\[Tau]\[Tau]\[Nu]"};*)
(*(*________________________________*)*)
(*(*l != l'*)*)
(*(*________________________________*)*)
(*M3bodyllpr\[Nu]=1/(2Sqrt[2]) SpinorUBar[k1,m1] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]*SpinorUBar[k2,m2] . GA[\[Mu]] . (1-GA5) . SpinorV[k3,m3]//Contract;*)
(*M3bodyllpr\[Nu]Star=ComplexConjugate[M3bodyllpr\[Nu]];*)
(*M3bodyllpr\[Nu]Squared[E1_,E3_,m_,m1_,m2_,m3_]=Simplify[Expand[FermionSpinSum[M3bodyllpr\[Nu] M3bodyllpr\[Nu]Star]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k,k2]->ProductKK2energy,ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k3]->ProductK1K3energy ,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k2,k3]-> ProductK2K3energy}//Simplify*)
(*Do[*)
(*fip=LLP;*)
(*Do[*)
(*mprodlist=ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListDecayProducts[LLP,proc]);*)
(*Msquared3BodyLLP[LLP,proc,E1_,E3_,mLLP_]=M3bodyllpr\[Nu]Squared[E1,E3,mLLP,m1,m2,m3]/.Table[Symbol["m"<>ToString[i]]->mprodlist[[i]],{i,1,3,1}]//Chop//Simplify*)
(*,{proc,Drop[procsleptonic[fip],-3]}]*)
(*,{LLP,HNLsList}]*)
(*(*________________________________*)*)
(*(*l = l'. Two contributions - from charged and from neutral currents*)*)
(*(*________________________________*)*)
(*M3bodyll\[Nu]=(1/(2Sqrt[2]) SpinorUBar[k1,m1] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]*SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorV[k2,m2]//Contract)+(1/(4Sqrt[2]) SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]*SpinorUBar[k1,m1] . GA[\[Mu]] . (1-4sin2\[Theta]w-GA5) . SpinorV[k2,m2]//Contract);*)
(*M3bodyll\[Nu]Star=ComplexConjugate[M3bodyll\[Nu]];*)
(*M3bodyll\[Nu]Squared[E1_,E3_,m_,m1_,m2_,m3_]=1/2 Simplify[Expand[FermionSpinSum[M3bodyll\[Nu] M3bodyll\[Nu]Star]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k,k2]->ProductKK2energy,ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k3]->ProductK1K3energy ,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k2,k3]-> ProductK2K3energy}//Simplify*)
(*Do[*)
(*fip=LLP;*)
(*Do[*)
(*mprodlist=ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListDecayProducts[fip,proc]);*)
(*Msquared3BodyLLP[LLP,proc,E1_,E3_, mLLP_]=M3bodyll\[Nu]Squared[E1,E3,mLLP,m1,m2,m3]/.Table[Symbol["m"<>ToString[i]]->mprodlist[[i]],{i,1,3,1}]/.{sin2\[Theta]w->0.23}//Chop//Simplify*)
(*,{proc,Drop[procsleptonic[fip],2]}]*)
(*,{LLP,HNLsList}]*)


(* ::Section:: *)
(*ALPs coupled to gluons*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="ALP-gluon";*)
(*BrRatiosALPgluonData[ma_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/Br-ratios-SensCalc-model-Gluon-scale-1000.-GeV.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=BrRatiosALPgluonData[ma][[1]]/.{"Jets"->"Jets-GG"};*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=ListBrRatios[LLPsel,mLLP_,procsel]=BrRatiosALPgluonData[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosALPgluonData[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-ss","Jets-cc","Jets-GG"},procsel]==True,"Yes","No"]*)
(*,{i,1,Length[BrRatiosALPgluonData[mLLP][[3]]],1}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Table[{ProcessesList[LLPsel,"True"][[i]],ListDecayProducts[LLPsel,ProcessesList[LLPsel,"True"][[i]]]},{i,1,Length[ProcessesList[LLPsel,"True"]],1}]//Transpose//TableForm*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatiosTemp[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsection:: *)
(*Squared matrix elements*)


(* ::Input:: *)
(*LLPsel="ALP-gluon";*)
(*MatrixElementsALPgluonList[ma_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/Matrix-elements-squared-model-Gluon-scale-1000.-GeV.m"}],"MX"];*)
(*Do[Msquared3BodyLLP[LLPsel,MatrixElementsALPgluonList[ma][[1]][[i]],E1_,E3_,mLLP_]=MatrixElementsALPgluonList[mLLP][[3]][[i]]*)
(*,{i,1,Length[MatrixElementsALPgluonList[ma][[3]]],1}];*)


(* ::Section:: *)
(*ALPs coupled to fermions*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="ALP-fermion";*)
(*BrRatiosALPfermionData[ma_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/Br-ratios-SensCalc-model-Fermion universal-scale-1000.-GeV.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=BrRatiosALPfermionData[ma][[1]]/.{"Jets"->"Jets-GG"};*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=ListBrRatios[LLPsel,mLLP_,procsel]=BrRatiosALPfermionData[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosALPfermionData[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-ss","Jets-cc","Jets-GG"},procsel]==True,"Yes","No"]*)
(*,{i,1,Length[BrRatiosALPfermionData[mLLP][[3]]],1}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatiosTemp[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsubsection:: *)
(*Old description from 1901.09966 - no hadronic decays*)


(* ::Input:: *)
(*LLPsel="ALP-fermion-no-hadronic-decays";*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Select[ProcessesList["ALP-fermion","True"],MemberQ[{"2e","2\[Mu]","2\[Tau]"},#]==True&];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=ListBrRatios[LLPsel,mLLP_,procsel]=ListBrRatios["ALP-fermion",mLLP,procsel]/(ListBrRatios["ALP-fermion",mLLP,"2e"]+ListBrRatios["ALP-fermion",mLLP,"2\[Mu]"]+ListBrRatios["ALP-fermion",mLLP,"2\[Tau]"])//Simplify;*)
(*ListDecayProducts[LLPsel,procsel]=ListDecayProducts["ALP-fermion",procsel];*)
(*JetsPresence[LLPsel,procsel]=If[procsel=="Jets-GG","Yes","No"]*)
(*,{i,1,Length[ProcessesList[LLPsel,"True"]],1}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatiosTemp[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsection:: *)
(*Squared matrix elements*)


(* ::Input:: *)
(*LLPsel="ALP-fermion";*)
(*MatrixElementsALPfermionList[ma_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/Matrix-elements-squared-model-Fermion universal-scale-1000.-GeV.m"}],"MX"];*)
(*Do[Msquared3BodyLLP[LLPsel,MatrixElementsALPfermionList[ma][[1]][[i]],E1_,E3_,mLLP_]=MatrixElementsALPfermionList[mLLP][[3]][[i]]*)
(*,{i,1,Length[MatrixElementsALPfermionList[ma][[3]]],1}];*)


(* ::Section:: *)
(*B-L mediator*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="B-L";*)
(*BrRatiosBLdata[mV_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/BrRatiosBL.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosBLdata[ma][[1]],-1]/.{"Jets"->"Jets-light"};*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosBLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosBLdata[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-light","Jets-cc"},procsel]==True,"Yes","No"]*)
(*,{i,1,Length[BrRatiosBLdata[mLLP][[3]]]-1,1}]*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+(BrRatiosBLdata[mV][[3]][[-1]]/.{mV->mLLP}))*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsection:: *)
(*Squared matrix elements*)


(* ::Subsubsection:: *)
(*B->3\[Pi] (following https://arxiv.org/pdf/1404.4370.pdf and Ref. therein)*)


(* ::Input:: *)
(*Propagator\[Rho][p_,m\[Rho]_,\[Mu]_,\[Nu]_]=(-MT[\[Mu],\[Nu]]+(FV[p,\[Mu]]FV[p,\[Nu]])/m\[Rho]^2)/(ScalarProduct[p,p]-m\[Rho]^2);*)
(*p\[Pi]0=p-p\[Pi]plus-p\[Pi]minus;*)
(*(*B\[Rho]0*)*)
(*MBLTo3\[Pi]1=LeviCivita[\[Mu],\[Nu],\[Rho],\[Sigma]]*FV[p,\[Mu]]*PolarizationVector[p,\[Nu]]*FV[p-p\[Pi]0,\[Rho]]*Propagator\[Rho][p-p\[Pi]0,m\[Rho],\[Sigma],\[Delta]]*FV[p\[Pi]plus-p\[Pi]minus,\[Delta]]//Contract//Simplify;*)
(*(*B\[Rho]+*)*)
(*MBLTo3\[Pi]2=LeviCivita[\[Mu],\[Nu],\[Rho],\[Sigma]]*FV[p,\[Mu]]*PolarizationVector[p,\[Nu]]*FV[p-p\[Pi]minus,\[Rho]]*Propagator\[Rho][p-p\[Pi]minus,m\[Rho],\[Sigma],\[Delta]]*FV[p\[Pi]plus-p\[Pi]0,\[Delta]]//Contract//Simplify;*)
(*(*B\[Rho]-*)*)
(*MBLTo3\[Pi]3=LeviCivita[\[Mu],\[Nu],\[Rho],\[Sigma]]*FV[p,\[Mu]]*PolarizationVector[p,\[Nu]]*FV[p-p\[Pi]plus,\[Rho]]*Propagator\[Rho][p-p\[Pi]plus,m\[Rho],\[Sigma],\[Delta]]*FV[p\[Pi]0-p\[Pi]minus,\[Delta]]//Contract//Simplify;*)
(*MBLTo3\[Pi]=MBLTo3\[Pi]1+MBLTo3\[Pi]2+MBLTo3\[Pi]3;*)
(*MBLTo3\[Pi]Star=ComplexConjugate[MBLTo3\[Pi]];*)
(*MBLTo3\[Pi]SquaredTemp=(DoPolarizationSums[MBLTo3\[Pi] MBLTo3\[Pi]Star,p]//Contract)/.{ScalarProduct[p\[Pi]minus,p\[Pi]minus]->m\[Pi]^2,ScalarProduct[p\[Pi]plus,p\[Pi]plus]->m\[Pi]^2,ScalarProduct[p\[Pi]0,p\[Pi]0]->m\[Pi]^2,ScalarProduct[p,p]->m^2}//Simplify;*)
(*p\[Pi]0//Clear*)
(*Msquared3BodyLLP["B-L","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1_,E3_,mLLP_]=(MBLTo3\[Pi]SquaredTemp/.{ScalarProduct[p\[Pi]plus,p\[Pi]minus]->ProductK1K2energy,ScalarProduct[p,p\[Pi]plus]->ProductKK1energy,ScalarProduct[p,p\[Pi]minus]->ProductKK2energy}/.{m1->m\[Pi],m2->m\[Pi],m3->m\[Pi],mB->mLLP,m->mLLP}//Simplify)/.{m\[Pi]->ParamProductMass[211.],m\[Rho]->ParamProductMass[113.]};*)


(* ::Section:: *)
(*B-3Subscript[L, \[Mu]] mediator*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="B-3Lmu";*)
(*BrRatiosBLdata[mV_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/BrRatiosBL.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosBLdata[ma][[1]],-1]/.{"Jets"->"Jets-light"};*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosBLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosBLdata[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-light","Jets-cc"},procsel]==True,"Yes","No"]*)
(*,{i,1,Length[BrRatiosBLdata[mLLP][[3]]]-1,1}]*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+(BrRatiosBLdata[mV][[3]][[-1]]/.{mV->mLLP}))*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Input:: *)
(*LLPsel="B-3Lmu";*)
(*Msquared3BodyLLP[LLPsel,"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1_,E3_,mLLP_]=Msquared3BodyLLP["B-L","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1,E3,mLLP];*)


(* ::Section:: *)
(*B-3 Subscript[L, e]-Subscript[L, \[Mu]]+Subscript[L, \[Tau]] mediator*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="B-3Le-Lmu+Ltau";*)
(*BrRatiosBLdata[mV_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/BrRatiosBL.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosBLdata[ma][[1]],-1];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosBLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosBLdata[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-light","Jets-cc"},procsel]==True,"Yes","No"]*)
(*,{i,1,Length[BrRatiosBLdata[mLLP][[3]]]-1,1}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+(BrRatiosBLdata[mV][[3]][[-1]]/.{mV->mLLP}))*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Input:: *)
(*LLPsel="B-3Le-Lmu+Ltau";*)
(*Msquared3BodyLLP[LLPsel,"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1_,E3_,mLLP_]=Msquared3BodyLLP["B-L","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1,E3,mLLP];*)


(* ::Section:: *)
(*B-Subscript[L, e]-3Subscript[L, \[Mu]]+Subscript[L, \[Tau]] mediator*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="B-Le-3Lmu+Ltau";*)
(*BrRatiosBLdata[mV_]=Import[FileNameJoin[{NotebookDirectory[],"phenomenology",LLPsel,"decay widths/BrRatiosBL.m"}],"MX"];*)
(*(*List of all representative processes*)*)
(*ProcessesList[LLPsel,"True"]=Drop[BrRatiosBLdata[ma][[1]],-1];*)
(*(*The mass above which all hadronic decays are approximated by decays into jets*)*)
(*Do[*)
(*procsel=ProcessesList[LLPsel,"True"][[i]];*)
(*ListBrRatiosTemp[LLPsel,mLLP_,procsel]=BrRatiosBLdata[mLLP][[3]][[i]];*)
(*ListDecayProducts[LLPsel,procsel]=BrRatiosBLdata[ma][[2]][[i]];*)
(*JetsPresence[LLPsel,procsel]=If[MemberQ[{"Jets-light","Jets-cc"},procsel]==True,"Yes","No"]*)
(*,{i,1,Length[BrRatiosBLdata[mLLP][[3]]]-1,1}]*)
(*Do[ListBrRatios[LLPsel,mLLP_,proc]=ListBrRatiosTemp[LLPsel,mLLP,proc]/(Sum[ListBrRatiosTemp[LLPsel,mLLP,pr],{pr,ProcessesList[LLPsel,"True"]}]+(BrRatiosBLdata[mV][[3]][[-1]]/.{mV->mLLP}))*)
(*,{proc,ProcessesList[LLPsel,"True"]}]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel];*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)
(*LogLogPlot[{Evaluate[Sum[ListBrRatios[LLPsel,mN,pr],{pr,ProcessesList[LLPsel,"True"]}]]},{mN,0.05,4.5},PlotRange->All]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Input:: *)
(*LLPsel="B-Le-3Lmu+Ltau";*)
(*Msquared3BodyLLP[LLPsel,"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1_,E3_,mLLP_]=Msquared3BodyLLP["B-L","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)",E1,E3,mLLP];*)


(* ::Section:: *)
(*ALPs coupled to photons*)


(* ::Subsection:: *)
(*List of decay processes and sets of decay products for them, branching ratios*)


(* ::Input:: *)
(*LLPsel="ALP-photon"*)
(*{ListBrRatiosTemp["ALP-photon",mLLP_,"\[Gamma]-pair"],ListDecayProducts["ALP-photon","\[Gamma]-pair"],JetsPresence["ALP-photon","\[Gamma]-pair"]}={1,{"\[Gamma]","\[Gamma]","Null","Null"},"No"};*)
(*ListBrRatios["ALP-photon",mLLP_,"\[Gamma]-pair"]=ListBrRatiosTemp["ALP-photon",mLLP,"\[Gamma]-pair"];*)
(*Print["All processes with at least two charged/neutral particles:"]*)
(*ProcessesList[LLPsel,"True"]=procList[LLPsel]*)
(*Print["All processes with at least two charged particles:"]*)
(*ProcessesList[LLPsel,"False"]=procListnoecal[LLPsel]*)
(*Print["Processes with jets:"]*)
(*Select[ProcessesList[LLPsel,"True"],JetsPresence[LLPsel,#]=="Yes"&]*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Section:: *)
(*LLPs - total*)


(* ::Input:: *)
(*LLPlist=Keys[DownValues@ProcessesList][[All,1,1]]//DeleteDuplicates*)
(*(*If decay products may be uncharged only/metastable decay product itself is uncharged*)*)
(*OnlyUnch["\[Omega]"]=0;*)
(*OnlyUnch["\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)"]=0;*)
(*OnlyUnch["\[Eta]"]=0;*)
(*OnlyUnch["\[Eta]'"]=0;*)
(*OnlyUnch["\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"]=1;*)
(*OnlyUnch["\!\(\*SubscriptBox[\(K\), \(L\)]\)"]=1;*)
(*OnlyUnch["\!\(\*SubscriptBox[\(K\), \(S\)]\)"]=0;*)
(*OnlyUnch["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(0\)\)]\)"]=OnlyUnch["\!\(\*SuperscriptBox[OverscriptBox[\(K\), \(_\)], \(\(*\)\(0\)\)]\)"]=0;*)
(*OnlyUnch["\!\(\*SubscriptBox[\(a\), \(1\)]\)"]=0;*)
(*OnlyUnch["\[Phi]"]=0;*)
(*(*The probability with which the given decay products will give at least two charged tracks*)*)
(*ecalfactor[LLP_,proc_]:=Block[{},*)
(*decayprodlist=Select[ListDecayProducts[LLP,proc],#!="Null"&];*)
(*decayprodpdglist=ParamProductToPDGid[#]&/@decayprodlist;*)
(*chargedprodscounter=Sum[If[ParamProductCharge[decayprodpdglist[[i]]]!=0.,1,0],{i,1,Length[decayprodpdglist]}];*)
(*If[chargedprodscounter>=2,val=1,*)
(*stability=ParamProductStability[#]&/@decayprodpdglist;*)
(*val=1-Product[If[stability[[i]]==0.,OnlyUnch[decayprodlist[[i]]],1],{i,1,Length[decayprodlist],1}]*)
(*];*)
(*val*)
(*]*)
(*Join[{{"LLP","Process","\!\(\*SubscriptBox[\(P\), \(\(>\)\(2\\\  charged\\\  particles\)\)]\)"}},Flatten[Table[{LLP,proc,ecalfactor[LLP,proc]},{LLP,LLPlist},{proc,ProcessesList[LLP,"True"]}],{1,2}]];*)
(*BrVisibleGivenSetup[LLP_,mLLP_,proclist_,ECALoption_]:=Block[{},*)
(*Sum[ListBrRatios[LLP,mLLP,proclist[[i]]]*If[ECALoption=="True",1,ecalfactor[LLP,proclist[[i]]]],{i,1,Length[proclist],1}]*)
(*]*)


(* ::Section:: *)
(*Unstable SM particles*)


(* ::Subsection:: *)
(*List of decay processes and decay products*)


(* ::Subsubsection:: *)
(*\[Tau] leptons*)


(* ::Input:: *)
(*{ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","e\[Nu]\[Nu]"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","\[Mu]\[Nu]\[Nu]"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","\[Pi]\[Nu]"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","2\[Pi]\[Nu]"]}={{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"}};*)
(*{ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","e\[Nu]\[Nu]"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","\[Mu]\[Nu]\[Nu]"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","\[Pi]\[Nu]"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","2\[Pi]\[Nu]"]}={{"\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"}};*)
(*{\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","e\[Nu]\[Nu]"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","\[Mu]\[Nu]\[Nu]"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","\[Pi]\[Nu]"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","2\[Pi]\[Nu]"]}={\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","e\[Nu]\[Nu]"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","\[Mu]\[Nu]\[Nu]"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","\[Pi]\[Nu]"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Tau]\), \(-\)]\)","2\[Pi]\[Nu]"]}={0.1739,0.1782,0.1082,0.2549};*)


(* ::Subsubsection:: *)
(*\[Eta],\[Eta]',\[Pi]^0*)


(* ::Input:: *)
(*{ListDecayProducts["\[Eta]","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\[Eta]","3\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\[Eta]","\[Gamma]-pair"]}={ {"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null"},{"\[Gamma]","\[Gamma]","Null","Null"}};*)
(*{\[Omega]process["\[Eta]","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\[Eta]","3\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\[Eta]","\[Gamma]-pair"]}={0.2302,0.3257,0.3936};*)
(*{ListDecayProducts["\[Eta]'","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\[Eta]"],ListDecayProducts["\[Eta]'","\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)\[Gamma]"],ListDecayProducts["\[Eta]'","2\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)\[Eta]"]}={ {"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\[Eta]","Null"},{"\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)","\[Gamma]","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Eta]","Null"}};*)
(*{\[Omega]process["\[Eta]'","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\[Eta]"],\[Omega]process["\[Eta]'","\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)\[Gamma]"],\[Omega]process["\[Eta]'","2\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)\[Eta]"]}={0.425,0.295,0.224};*)
(*ListDecayProducts["\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Gamma]-pair"]={"\[Gamma]","\[Gamma]","Null","Null"};*)
(*\[Omega]process["\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Gamma]-pair"]=1;*)


(* ::Subsubsection:: *)
(*\[Rho], \[Omega], \[Phi], Subscript[a, 1]*)


(* ::Input:: *)
(*{ListDecayProducts["\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(charged\)]\)-pair"]}={{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"}};*)
(*{\[Omega]process["\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(charged\)]\)-pair"]}={1,1,1};*)
(*{ListDecayProducts["\[Omega]","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\[Omega]","\[Pi]\[Gamma]"]}={{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Gamma]","Null","Null"}};*)
(*{\[Omega]process["\[Omega]","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\[Omega]","\[Pi]\[Gamma]"]}={0.892,0.0835};*)
(*{ListDecayProducts["\[Phi]","\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)"],ListDecayProducts["\[Phi]","\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],ListDecayProducts["\[Phi]","\!\(\*SuperscriptBox[\(K\), \(+\)]\)\!\(\*SuperscriptBox[\(K\), \(-\)]\)"],ListDecayProducts["\[Phi]","2\!\(\*SuperscriptBox[\(K\), \(0\)]\)"]}={{"\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(K\), \(+\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)","Null","Null"},{"\!\(\*SubscriptBox[\(K\), \(L\)]\)","\!\(\*SubscriptBox[\(K\), \(S\)]\)","Null","Null"}};*)
(*{\[Omega]process["\[Phi]","\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)"],\[Omega]process["\[Phi]","\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],\[Omega]process["\[Phi]","\!\(\*SuperscriptBox[\(K\), \(+\)]\)\!\(\*SuperscriptBox[\(K\), \(-\)]\)"],\[Omega]process["\[Phi]","2\!\(\*SuperscriptBox[\(K\), \(0\)]\)"]}={0.1532/2,0.1532/2,0.489,0.342};*)
(*{ListDecayProducts["\!\(\*SubscriptBox[\(a\), \(1\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],ListDecayProducts["\!\(\*SubscriptBox[\(a\), \(1\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)"]}={{"\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"}};*)
(*{\[Omega]process["\!\(\*SubscriptBox[\(a\), \(1\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],\[Omega]process["\!\(\*SubscriptBox[\(a\), \(1\)]\)","\!\(\*SuperscriptBox[\(\[Rho]\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)"]}={0.5,0.5};*)


(* ::Subsubsection:: *)
(*SuperStar[K],Subscript[K, S]*)


(* ::Input:: *)
(*{ListDecayProducts["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(+\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(-\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],ListDecayProducts["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(0\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],ListDecayProducts["\!\(\*SuperscriptBox[OverscriptBox[\(K\), \(_\)], \(\(*\)\(0\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)"]}={{"\!\(\*SuperscriptBox[\(K\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(K\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(K\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(K\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"}};*)
(*{\[Omega]process["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(+\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(-\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"],\[Omega]process["\!\(\*SuperscriptBox[\(K\), \(\(*\)\(0\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],\[Omega]process["\!\(\*SuperscriptBox[OverscriptBox[\(K\), \(_\)], \(\(*\)\(0\)\)]\)","\!\(\*SuperscriptBox[\(K\), \(-\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)"]}={1,1,1,1};*)
(*{ListDecayProducts["\!\(\*SubscriptBox[\(K\), \(S\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],ListDecayProducts["\!\(\*SubscriptBox[\(K\), \(S\)]\)","2\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"]}={{"\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","Null","Null"}};*)
(*{\[Omega]process["\!\(\*SubscriptBox[\(K\), \(S\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)"],\[Omega]process["\!\(\*SubscriptBox[\(K\), \(S\)]\)","2\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)"]}={0.6920,0.3069};*)


(* ::Subsection:: *)
(*Matrix elements*)


(* ::Input:: *)
(*ListSMdecays=Join[Partition[Keys[DownValues@\[Omega]process][[All,1,1]],1],Partition[Keys[DownValues@\[Omega]process][[All,1,2]],1],2];*)
(*Do[Msquared3BodySMparticles[ListSMdecays[[i]][[1]],ListSMdecays[[i]][[2]],E1_,E3_,m_]=1,{i,1,Length[ListSMdecays],1}]*)
(*(*Table[With[{part=ListSMdecays[[i]][[1]],proc=ListSMdecays[[i]][[2]]},Evaluate[{part,proc,ListDecayProducts[part,proc][[1]],ListDecayProducts[part,proc][[2]],ListDecayProducts[part,proc][[3]],ListDecayProducts[part,proc][[4]],\[Omega]process[part,proc]}]],{i,1,Length[ListSMdecays],1}]*)*)


(* ::Chapter::Closed:: *)
(*Phase space of decay products at the rest frame of the decaying LLP *)


(* ::Section:: *)
(*Phase space of decay products - generated on-flight*)


(* ::Subsection:: *)
(*Phase space of LLP's decays at its rest frame - 2-body decays*)


(* ::Input:: *)
(*(*Computation of the phase space of 2-body products: 4-momenta, mass, pdg, electric charge, whether stable or not*)*)
(*nVectorParticles=Compile[{{\[Theta]vals,_Real},{\[Phi]vals,_Real},{E1,_Real},{E2,_Real},{m1,_Real},{m2,_Real},{pdg1,_Real},{pdg2,_Real},{charge1,_Real},{charge2,_Real},{stability1,_Real},{stability2,_Real}},*)
(*Module[{pmod,px1,px2,py1,py2,pz1,pz2},*)
(*pmod=Sqrt[E1^2-m1^2];*)
(*px1=pmod*Sin[\[Theta]vals]*Cos[\[Phi]vals];*)
(*px2=-px1;*)
(*py1=pmod*Sin[\[Theta]vals]*Sin[\[Phi]vals];*)
(*py2=-py1;*)
(*pz1=pmod*Cos[\[Theta]vals];*)
(*pz2=-pz1;*)
(*{px1,py1,pz1,E1,m1,pdg1,charge1,stability1,px2,py2,pz2,E2,m2,pdg2,charge2,stability2}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}];*)
(*joincompiled=Compile[{{tab1,_Real,2},{tab2,_Real,2},{tab3,_Real,2}},Join[tab1[[All,{1,2,3,4,5}]],tab2,tab1[[All,{6,7,8,9,10}]],tab3,2],CompilationTarget->"C",RuntimeOptions->"Speed"]*)
(*Block2BodyDistrAtRest[m_,product1_,product2_,Nevents_]:=Module[{\[Theta]tab,\[Phi]tab,E1v,E2v,mass1,mass2,pdg1,pdg2,charge1,charge2,stability1,stability2},*)
(*{pdg1,pdg2}=ParamProductToPDGid[#]&/@{product1,product2};*)
(*{mass1,mass2}=ParamProductMass[#]&/@{pdg1,pdg2};*)
(*{charge1,charge2}=ParamProductCharge[#]&/@{pdg1,pdg2};*)
(*{stability1,stability2}=ParamProductStability[#]&/@{pdg1,pdg2};*)
(*(*Random values of \[Theta] and \[Phi]. For \[Theta], the distribution in cos\[Theta] is uniform, hence one first generates random values from -1 to 1 and then computes ArcCos*)*)
(*\[Theta]tab=ArcCos[RandomReal[{-1,1},Nevents]];*)
(*\[Phi]tab=RandomReal[{-Pi,Pi},Nevents];*)
(*{E1v,E2v}={(m^2+mass1^2-mass2^2)/(2*m),(m^2+mass2^2-mass1^2)/(2*m)};*)
(*nVectorParticles[\[Theta]tab,\[Phi]tab,E1v,E2v,mass1,mass2,pdg1,pdg2,charge1,charge2,stability1,stability2]]*)
(*(*Columns for the decay product phase space expressed in terms of 4-momenta*)*)
(*indexpx1=1;*)
(*indexpy1=2;*)
(*indexpz1=3;*)
(*indexE1=4;*)
(*indexm1=5;*)
(*indexpdg1=6;*)
(*indexcharge1=7;*)
(*indexstability1=8;*)
(*LengthDataProduct=indexstability1;*)


(* ::Subsection:: *)
(*Phase space of LLP's decays at its rest frame - 3-body decays*)


(* ::Input:: *)
(*BlockRandomEnergiesOld=Compile[{m,m1,m2,m3},Module[{E1r=0.,E2v=0.,E3r=0.},While[E3r=RandomReal[{m3,(m^2+m3^2-(m1+m2)^2)/(2*m)}];*)
(*E1r=RandomReal[{m1,(m^2+m1^2-(m2+m3)^2)/(2*m)}];*)
(*E2v=m-E1r-E3r;*)
(*E2v<=m2||(E2v^2-m2^2-(E1r^2-m1^2)-(E3r^2-m3^2))^2>=4*(E1r^2-m1^2)*(E3r^2-m3^2)];*)
(*{E1r,E3r}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True];*)
(*BlockRandomEnergiesOld1=With[{br=BlockRandomEnergiesOld},Hold@Compile[{m,m1,m2,m3,{Nevents,_Integer}},Table[br[m,m1,m2,m3],Nevents],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True,CompilationOptions->{"InlineCompiledFunctions"->True}]//ReleaseHold];*)
(*(*The idea (following "Particle kinematics" by Byckling and Kajantie):*)*)
(*(*Generate the random energies Subscript[E, 1],Subscript[E, 3] with the weight being the squared matrix element of the decay process*)*)
(*(*Restore full 4-momenta*)*)
(*NN=10^5;*)
(*(*The routine that computes the weights M^2(Subscript[E, 1],Subscript[E, 3])Subscript[\[CapitalDelta]E, 3](Subscript[E, 1]) for the given uniformly distributed Subscript[E, 1],Subscript[E, 3]*)*)
(*weightsNonUniformComp:=Hold@Compile[{{tabe1e3,_Real,1},MASSM,MASS1,MASS2,MASS3},Module[{e1,e3},*)
(*e1=Compile`GetElement[tabe1e3,1];*)
(*e3=Compile`GetElement[tabe1e3,2];*)
(*distr[e1,e3](**\[CapitalDelta]E3[e1,MASSM,MASS1,MASS2,MASS3]*)*)
(*],CompilationTarget->"MVM",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{distr(*,\[CapitalDelta]E3*)}]//ReleaseHold;*)
(*weightsUniformComp=Hold@Compile[{{tabe1e3,_Real,1},MASSM,MASS1,MASS2,MASS3},Module[{e1,e3},*)
(*e1=Compile`GetElement[tabe1e3,1];*)
(*\[CapitalDelta]E3[e1,MASSM,MASS1,MASS2,MASS3]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{\[CapitalDelta]E3}]//ReleaseHold;*)
(*E3valsComp=Hold@Compile[{{E1vals,_Real},MASSM,MASS1,MASS2,MASS3},Module[{e3max,e3min},*)
(*e3min=E3domainMin[E1vals,MASSM,MASS1,MASS2,MASS3];*)
(*e3max=E3domainMax[E1vals,MASSM,MASS1,MASS2,MASS3];*)
(*RandomReal[{e3min,e3max}]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{E3domainMax,E3domainMin}]//ReleaseHold;*)
(*BlockRandomEnergies[m_,m1_,m2_,m3_,Nevents_,distr_]:=Block[{},*)
(*(*E1maxval=E1domainMax[m,m1,m2,m3];*)
(*E1vals=RandomReal[{m1,E1maxval},Max[NN,Nevents]];*)
(*E3vals=E3valsComp[E1vals,m,m1,m2,m3];*)
(*tabE1E3unweighted={E1vals,E3vals}//Transpose;*)*)
(*(*Weights for the generated values of {E1,E3} from matrix element squared*)*)
(*If[distr[RandomReal[{m1,E1domainMax[m,m1,m2,m3]}],RandomReal[{m3,(m^2+m3^2-(m1+m2)^2)/(2*m)}]]!=1,*)
(*(*Table with random energies distributed in the Dalitz range before accounting for weights*)*)
(*tabE1E3unweighted=BlockRandomEnergiesOld1[m,m1,m2,m3,Max[Nevents,NN]];*)
(*(*Weights from matrix element*)*)
(*weights1=weightsNonUniformComp;*)
(*weights=Abs[weights1[tabE1E3unweighted,m,m1,m2,m3](*/._?Negative\[Rule]0*)];*)
(*(*True random energies. Computed via empirical distribution from the weigthed data*)*)
(*tabsel=RandomChoice[weights->tabE1E3unweighted,Nevents];*)
(*,*)
(*tabsel=BlockRandomEnergiesOld1[m,m1,m2,m3,Nevents];*)
(*];*)
(*tabsel*)
(*(*(*Weighted random points*)*)
(*weightedData=WeightedData[tabE1E3unweighted,weights];*)
(*(*True random energies. Computed via empirical distribution from the weigthed data*)*)
(*edist=EmpiricalDistribution[weightedData];*)
(*RandomVariate[edist,Nevents];*)*)
(*]*)
(*(*Phase space of 3-body decays at rest. Returns blocks with the following data: productdata = Subscript[p, x],Subscript[p, y],Subscript[p, z],E,m,pdg,charge,stability*)*)
(*tabPS3bodyCompiled=Hold@Compile[{{tabPSenergies,_Real,1},{MASSM,_Real},{MASS1,_Real},{MASS2,_Real},{MASS3,_Real},{pdg1,_Real},{pdg2,_Real},{pdg3,_Real},{charge1,_Real},{charge2,_Real},{charge3,_Real},{stability1,_Real},{stability2,_Real},{stability3,_Real}},*)
(*Module[{eprod1,eprod2,eprod3,pxprod1,pxprod2,pxprod3,pyprod1,pyprod2,pyprod3,pzprod1,pzprod2,pzprod3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab},*)
(*eprod1=Compile`GetElement[tabPSenergies,1];*)
(*eprod3=Compile`GetElement[tabPSenergies,2];*)
(*(*Angles relating generated energies to the 4-momenta*)*)
(*\[Theta]randTab=ArcCos[RandomReal[{-1,1}]];*)
(*\[Phi]randTab=RandomReal[{-Pi,Pi}];*)
(*\[Kappa]randTab=RandomReal[{-Pi,Pi}];*)
(*eprod2=MASSM-eprod1-eprod3;*)
(*pxprod1=p1rotatedX[eprod1,MASS1,\[Theta]randTab,\[Phi]randTab];*)
(*pyprod1=p1rotatedY[eprod1,MASS1,\[Theta]randTab,\[Phi]randTab];*)
(*pzprod1=p1rotatedZ[eprod1,MASS1,\[Theta]randTab,\[Phi]randTab];*)
(*pxprod2=p2rotatedX[eprod1,eprod3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*pyprod2=p2rotatedY[eprod1,eprod3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*pzprod2=p2rotatedZ[eprod1,eprod3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*pxprod3=p3rotatedX[eprod1,eprod3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*pyprod3=p3rotatedY[eprod1,eprod3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*pzprod3=p3rotatedZ[eprod1,eprod3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*{pxprod1,pyprod1,pzprod1,eprod1,MASS1,pdg1,charge1,stability1,pxprod2,pyprod2,pzprod2,eprod2,MASS2,pdg2,charge2,stability2,pxprod3,pyprod3,pzprod3,eprod3,MASS3,pdg3,charge3,stability3}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}]/.ruleDown[{p1rotatedX,p1rotatedY,p1rotatedZ,p2rotatedX,p2rotatedY,p2rotatedZ,p3rotatedX,p3rotatedY,p3rotatedZ}]//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@tabPS3bodyCompiled;*)
(*ThreeBodyDecaysEventsAtRest[particle_,SpecificDecay_,mparticle_,Nevents_]:=Module[{(*pdg1,pdg2,pdg3,MASSM,MASS1,MASS2,MASS3,charge1,charge2,charge3,stability1,stability2,stability3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab,(*tabRPPS,weights1,weights,*)decayproductsset,weightedData,edist,tabPSenergies*)},*)
(*(*___________________________________*)*)
(*(*Extracting information about the decay*)*)
(*MASSM =If[!MemberQ[LLPlist,particle],ParamProductMass[ParamProductToPDGid[particle]],mparticle];*)
(*decayproductsset=Select[ListDecayProducts[particle,SpecificDecay],#!="Null"&];*)
(*{pdg1,pdg2,pdg3}=ParamProductToPDGid[#]&/@decayproductsset;*)
(*{MASS1,MASS2,MASS3}=ParamProductMass[#]&/@{pdg1,pdg2,pdg3};*)
(*{charge1,charge2,charge3}=ParamProductCharge[#]&/@{pdg1,pdg2,pdg3};*)
(*{stability1,stability2,stability3}=ParamProductStability[#]&/@{pdg1,pdg2,pdg3};*)
(*(*The squared matrix element for the process - to compute weights*)*)
(*distr[E1_,E3_]=If[!MemberQ[LLPlist,particle],Msquared3BodySMparticles[particle,SpecificDecay,E1,E3,MASSM],Msquared3BodyLLP[particle,SpecificDecay,E1,E3,MASSM]];*)
(*(*___________________________________*)*)
(*(*Generating the true Subscript[E, 1],Subscript[E, 3] for the decay process 0->1+2+3*)*)
(*(*___________________________________*)*)
(*tabE1E3true=BlockRandomEnergies[MASSM,MASS1,MASS2,MASS3,Nevents,distr];*)
(*tabPS3bodyCompiled[tabE1E3true,MASSM,MASS1,MASS2,MASS3,pdg1,pdg2,pdg3,charge1,charge2,charge3,stability1,stability2,stability3]*)
(*]*)


(* ::Subsection:: *)
(*Boosts of decay products to lab frame of the decaying particle (for decay products of unstable decay products)*)


(* ::Input:: *)
(*(*Consider the data for mother particle, and the data for daughter particles: the block below evaluates boost for the given daughter*)*)
(*TabBoostedDecayProductComp=Hold@Compile[{{tabmother,_Real,1},{tabdaughters,_Real,1},{daughter,_Integer}},Module[{pxmother,pymother,pzmother,Emother,mmother,pxdaughter,pydaughter,pzdaughter,Edaughter,mdaughter=0.,pxboosted=0.,pyboosted=0.,pzboosted=0.,Eboosted=0.,pdgdaughter,chargedaughter=0.,stabilitydaughter=0.},*)
(*pdgdaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexpdg1];*)
(*If[pdgdaughter!=-999.,*)
(*pxmother=Compile`GetElement[tabmother,indexpx1];*)
(*pymother=Compile`GetElement[tabmother,indexpy1];*)
(*pzmother=Compile`GetElement[tabmother,indexpz1];*)
(*Emother=Compile`GetElement[tabmother,indexE1];*)
(*mmother=Compile`GetElement[tabmother,indexm1];*)
(*pxdaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexpx1];*)
(*pydaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexpy1];*)
(*pzdaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexpz1];*)
(*Edaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexE1];*)
(*mdaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexm1];*)
(*chargedaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexcharge1];*)
(*stabilitydaughter=Compile`GetElement[tabdaughters,(daughter-1)*LengthDataProduct+indexstability1];*)
(*pxboosted=pproductLab1Cart[pxmother,pymother,pzmother,Emother,mmother,pxdaughter,pydaughter,pzdaughter,Edaughter];*)
(*pyboosted=pproductLab2Cart[pxmother,pymother,pzmother,Emother,mmother,pxdaughter,pydaughter,pzdaughter,Edaughter];*)
(*pzboosted=pproductLab3Cart[pxmother,pymother,pzmother,Emother,mmother,pxdaughter,pydaughter,pzdaughter,Edaughter];*)
(*Eboosted=EproductLabCart[pxmother,pymother,pzmother,Emother,mmother,pxdaughter,pydaughter,pzdaughter,Edaughter],*)
(*pxboosted=pyboosted=pzboosted=Eboosted=mdaughter=pdgdaughter=chargedaughter=stabilitydaughter=-999.;*)
(*];*)
(*{pxboosted,pyboosted,pzboosted,Eboosted,mdaughter,pdgdaughter,chargedaughter,stabilitydaughter}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}]/.ruleDown[{pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{indexpx1,indexpy1,indexpz1,indexE1,indexm1,indexpdg1,indexcharge1,indexstability1,LengthDataProduct}]//ReleaseHold*)
(*(*This block joins the boosted data for all daughters*)*)
(*TabBoostedDecayProducts[tablemother_,tabledaughters_]:=Module[{},*)
(*numberdaughters=Length[tabledaughters[[1]]]/LengthDataProduct;*)
(*TableBoosted=Table[TabBoostedDecayProductComp[tablemother,tabledaughters,i],{i,1,numberdaughters,1}];*)
(*Join[##,2]&@@TableBoosted*)
(*]*)


(* ::Subsection:: *)
(*Phase space of LLP's decays at its rest frame - 4-body decays*)


(* ::Subsubsection:: *)
(*Definitions*)


(* ::Input:: *)
(*(*The idea (following "Particle kinematics" by Byckling and Kajantie):*)*)
(*(*Represent the process 0\[Rule]1+2+3+4 as 0\[Rule]1+234, 234\[Rule]2+34,34\[Rule]3+4*)*)
(*(*Generate the random "masses" Subscript[m, 234],Subscript[m, 34] with the weight being the jacobian of the phase space represented via these subsequent 2-body decays*)*)
(*(*Generate the phase space of these 2-body decays at rest, and then boost it by the momentum of the decaying "particle" in its lab frame*)*)
(*nVectorParticlesIntermediateComp=Compile[{{\[Theta]vals,_Real},{\[Phi]vals,_Real},{MassMatrix,_Real,1},{StabilityMatrix,_Real,1},{ChargeMatrix,_Real,1},{PDGMatrix,_Real,1},{ival,_Integer}},*)
(*Module[{pmod,m0val,m1val,m2val,E1val,E2val,px1,px2,py1,py2,pz1,pz2,stability1,stability2,charge1,charge2,pdg1,pdg2},*)
(*m0val=Compile`GetElement[MassMatrix,2*(ival-1)+1];*)
(*m1val=Compile`GetElement[MassMatrix,2*(ival-1)+2];*)
(*m2val=Compile`GetElement[MassMatrix,2*(ival-1)+3];*)
(*stability1=StabilityMatrix[[2*(ival-1)+1]];*)
(*stability2=StabilityMatrix[[2*(ival-1)+2]];*)
(*charge1=ChargeMatrix[[2*(ival-1)+1]];*)
(*charge2=ChargeMatrix[[2*(ival-1)+2]];*)
(*pdg1=PDGMatrix[[2*(ival-1)+1]];*)
(*pdg2=PDGMatrix[[2*(ival-1)+2]];*)
(*E1val=(m0val^2+m1val^2-m2val^2)/(2m0val);*)
(*E2val=(m0val^2-m1val^2+m2val^2)/(2m0val);*)
(*pmod=\[Sqrt](E1val^2-m1val^2);*)
(*px1=pmod*Sin[\[Theta]vals]*Cos[\[Phi]vals];*)
(*px2=-px1;*)
(*py1=pmod*Sin[\[Theta]vals]*Sin[\[Phi]vals];*)
(*py2=-py1;*)
(*pz1=pmod*Cos[\[Theta]vals];*)
(*pz2=-pz1;*)
(*{px1,py1,pz1,E1val,m1val,pdg1,charge1,stability1,px2,py2,pz2,E2val,m2val,pdg2,charge2,stability2}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}];*)
(*nVectorParticlesIntermediate[MassMatrix_,StabilityMatrix_,ChargeMatrix_,PDGMatrix_,ival_]:=Module[{\[Theta]vals,\[Phi]vals},*)
(*\[Theta]vals=ArcCos[RandomReal[{-1,1},Length[MassMatrix]]];*)
(*\[Phi]vals=RandomReal[{-Pi,Pi},Length[MassMatrix]];*)
(*nVectorParticlesIntermediateComp[\[Theta]vals,\[Phi]vals,MassMatrix,StabilityMatrix,ChargeMatrix,PDGMatrix,ival]*)
(*]*)
(*(*Block computing random masses*)*)
(*\[Lambda]f[a_,b_,c_]=a^2+b^2+c^2-2*(a*b+b*c+a*c);*)
(*Jacobian4body[m_,m1_,m2_,m3_,m4_,m234_,m34_]=(Sqrt[\[Lambda]f[m^2,m1^2,m234^2]]/(2m))(Sqrt[\[Lambda]f[m234^2,m2^2,m34^2]]/(2m234))(Sqrt[\[Lambda]f[m34^2,m3^2,m4^2]]/(2m34));*)
(*BlockFalseRandomMasses=Compile[{m,m1,m2,m3,m4,{Nevents,_Integer}},Module[{m234list,m34list},*)
(*m234list=RandomReal[{m2+m3+m4,m-m1},Nevents];*)
(*m34list=Table[RandomReal[{m3+m4,m234list[[i]]-m2}],{i,1,Length[m234list],1}];*)
(*{m234list,m34list}//Transpose*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed"]*)
(*WeightsComp=Hold@Compile[{m,m1,m2,m3,m4,{falserandmass,_Real,1}},*)
(*Module[{m234,m34},*)
(*m234=Compile`GetElement[falserandmass,1];*)
(*m34=Compile`GetElement[falserandmass,2];*)
(*(m234-m2-m3-m4)Jacobian4body[m,m1,m2,m3,m4,m234,m34]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",Parallelization->True,RuntimeAttributes->{Listable}]/.ruleDown[{Jacobian4body}]//ReleaseHold*)
(*BlockTrueRandomMasses[m_,m1_,m2_,m3_,m4_,Nevents_]:=Module[{FalseRandMasses},*)
(*NN=10^5;*)
(*FalseRandMasses=BlockFalseRandomMasses[m,m1,m2,m3,m4,NN];*)
(*WeightsVals=WeightsComp[m,m1,m2,m3,m4,FalseRandMasses];*)
(*(*Weighted random points*)*)
(*(*weightedData=WeightedData[FalseRandMasses,WeightsVals];*)
(*(*True random energies. Computed via empirical distribution from the weigthed data*)*)
(*edist=EmpiricalDistribution[weightedData];*)
(*tabMasses=RandomVariate[edist,Nevents]*)*)
(*tabMasses=RandomChoice[WeightsVals->FalseRandMasses,Nevents]*)
(*]*)


(* ::Subsubsection:: *)
(*Final block producing phase space*)


(* ::Input:: *)
(*FourBodyDecaysEventsAtRest[m_,product1_,product2_,product3_,product4_,Nevents_]:=Module[{},*)
(*(*List of pdg products involving in the decay. The "Intermediate" products correspond to the fake 234 and 34 particles*)*)
(*pdglist={ParamProductToPDGid[product1],ParamProductToPDGid["Intermediate"],ParamProductToPDGid[product2],ParamProductToPDGid["Intermediate"],ParamProductToPDGid[product3],ParamProductToPDGid[product4]};*)
(*(*Masses, electric charges, and stabilities of true decay products*)*)
(*finalproductmasses=ParamProductMass[#]&/@{pdglist[[1]],pdglist[[3]],pdglist[[5]],pdglist[[6]]};*)
(*qlist=ParamProductCharge[#]&/@pdglist;*)
(*stabilitylist=ParamProductStability[#]&/@pdglist;*)
(*(*Values of invariant masses Subscript[m, 234], Subscript[m, 34]*)*)
(*randommasses=BlockTrueRandomMasses[m,finalproductmasses[[1]],finalproductmasses[[2]],finalproductmasses[[3]],finalproductmasses[[4]],Nevents];*)
(*(*The matrix m, Subscript[m, product1],Subscript[m, 234],Subscript[m, product2],Subscript[m, 34],Subscript[m, product3],Subscript[m, product4]*)*)
(*mmatrix=Join[Table[{m,finalproductmasses[[1]]},Nevents],randommasses[[All,{1}]],Table[{finalproductmasses[[2]]},Nevents],randommasses[[All,{2}]],Table[{finalproductmasses[[3]],finalproductmasses[[4]]},Nevents],2];*)
(*(*Producing the phase space of fake 2-body decays 234->2+34 and 34->3+4 at rest of 234 and 34*)*)
(*Do[phasespacerest[ival]=nVectorParticlesIntermediate[mmatrix,stabilitylist,qlist,pdglist,ival],{ival,1,3,1}];*)
(*(*Boosting them according to the lab frames*)*)
(*phasespaceboosted2=TabBoostedDecayProducts[phasespacerest[1][[All,LengthDataProduct+Range[1,LengthDataProduct]]],phasespacerest[2]];*)
(*phasespaceboosted3=TabBoostedDecayProducts[phasespaceboosted2[[All,LengthDataProduct+Range[1,LengthDataProduct]]],phasespacerest[3]];*)
(*Join[phasespacerest[1][[All,Range[1,LengthDataProduct]]],phasespaceboosted2[[All,Range[1,LengthDataProduct]]],phasespaceboosted3,2]*)
(*]*)


(* ::Subsection:: *)
(*Phase space of STABLE LLP's decay products - overall definition*)


(* ::Input:: *)
(*{topology[2],topology[3],topology[4]}={"2-body","3-body","4-body"};*)
(*NeventsSplitted[Nev_,\[Omega]list_]:=Block[{},*)
(*NevTemp=IntegerPart[(Nev*\[Omega]list)/(\[Omega]list//Total)];*)
(*PosMax=Position[NevTemp,Max[NevTemp]][[1]][[1]];*)
(*NevTemp[[PosMax]]+=Nev-Total[NevTemp];*)
(*NevTemp*)
(*]*)
(*PhaseSpaceStableFromUnstableBlock[DataUnstableAtLLPrestFrame_]:=Block[{},*)
(*pdgprod=DataUnstableAtLLPrestFrame[[1]][[indexpdg1]];*)
(*massUnstableDecayProduct=DataUnstableAtLLPrestFrame[[1]][[indexm1]];*)
(*UnstableDecayProduct=ParamPDGidToProduct[pdgprod];*)
(*DecProcList=Select[ListSMdecays,#[[1]]==UnstableDecayProduct&][[All,2]];*)
(*DecProdList=ListDecayProducts[UnstableDecayProduct,#]&/@DecProcList;*)
(*\[Omega]list=\[Omega]process[UnstableDecayProduct,#]&/@DecProcList;*)
(*TopologyList=topology[Length[Select[#,#!="Null"&]]]&/@DecProdList;*)
(*NevList=NeventsSplitted[Length[DataUnstableAtLLPrestFrame],\[Omega]list];*)
(*UnstableDecayProductSplitted=Table[UnstableDecayProduct,{i,1,Length[\[Omega]list],1}];*)
(*phasespace={{}};*)
(*Do[*)
(*If[NevList[[i]]!=0.,*)
(*PhaseSpaceUnstableToStableAtUnstableRest=If[TopologyList[[i]]=="3-body",ThreeBodyDecaysEventsAtRest[UnstableDecayProduct,DecProcList[[i]],massUnstableDecayProduct,NevList[[i]]],Block2BodyDistrAtRest[massUnstableDecayProduct,DecProdList[[i]][[1]],DecProdList[[i]][[2]],NevList[[i]]]];*)
(*phasespace=Join[phasespace,PhaseSpaceUnstableToStableAtUnstableRest];*)
(*]*)
(*,{i,1,Length[\[Omega]list],1}];*)
(*phasespace=Drop[PadRight[phasespace,Automatic,-999.],1]//Developer`ToPackedArray;*)
(*TabBoostedDecayProducts[DataUnstableAtLLPrestFrame,RandomSample[phasespace]]*)
(*(*DecayProductsList=ListDecayProducts[UnstableDecayProduct,SpecificProcessUnstable];*)
(*Topology=topology[Length[Select[DecayProductsList,#\[NotEqual]"Null"&]]];*)
(*PhaseSpaceUnstableToStableAtUnstableRest=If[Topology\[Equal]"3-body",ThreeBodyDecaysEventsAtRest[UnstableDecayProduct,SpecificProcessUnstable,massUnstableDecayProduct,Nevents],Block2BodyDistrAtRest[massUnstableDecayProduct,DecayProductsList[[1]],DecayProductsList[[2]],Nevents]];*)
(*TabBoostedDecayProducts[DataUnstableAtLLPrestFrame,PhaseSpaceUnstableToStableAtUnstableRest]*)*)
(*]*)


(* ::Input:: *)
(**)


(* ::Subsubsection:: *)
(*Final table*)


(* ::Input:: *)
(*(*The code checking whether the given phase space contains unstable particles*)*)
(*stabilitycheck=Hold@Compile[{{data,_Real,1}},Module[{len=Length[data]/LengthDataProduct,stabval=1.},*)
(*Do[*)
(*stabval=Boole[!(Compile`GetElement[data,LengthDataProduct*(i-1)+indexstability1]==0.)];*)
(*If[stabval==0.,Break[]];*)
(*,{i,1,len,1}];*)
(*stabval*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{LengthDataProduct,indexstability1}]//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@stabilitycheck;*)
(*(*Code that takes the given set of columns corresponding to ith decay product and splits it onto distinguish decay produts different by pdg*)*)
(*PhaseSpaceSplitter[phasespace_]:=Module[{grouped,lengths,positions,ranges},*)
(*pdgs=phasespace[[All,indexpdg1]];*)
(*(*Grouping consecutive identical elements*)*)
(*grouped=Split[pdgs];*)
(*(*Calculating the lengths of each group*)*)
(*lengths=Length/@grouped;*)
(*(*Generating the start positions*)*)
(*positions=Accumulate[Prepend[lengths,0]];*)
(*(*Forming ranges*)*)
(*ranges=Transpose[{Most[positions]+1,Most[positions]+lengths}];*)
(*Take[phasespace,{#[[1]],#[[2]]}]&/@ranges*)
(*]*)
(*(*The code that goes over all rows of the given phase space and extracts *)*)
(*(*Phase space of the STABLE decay products Subscript[product, 1], Subscript[product, 2] from the process LLP \[Rule] Subscript[product, 1] + Subscript[product, 2] + ... at the LLP rest frame*)*)
(*(*The phase space is in the form of the following columns: {Subscript[\[Theta], product], Subscript[\[Phi], product], Subscript[E, product], Subscript[m, product], Subscript[pdg, product], Subscript[Q, EM,product],Subscript[stability, product]}*)*)
(*PhaseSpaceDecaysRest[LLP_,mLLP_,SpecificProcess_,Nevents_]:=Block[{},*)
(*(*List of the decay products*)*)
(*productslist=Select[ListDecayProducts[LLP,SpecificProcess],#!="Null"&];*)
(*(*Topology of the decay process: 2-, 3-, or 4-body decay*)*)
(*Topology=topology[Length[productslist]];*)
(*(*Phase space of the decay products of LLP. At this stage, one may have ustable decay products*)*)
(*decayProducts1=decayProductsTemp=If[Topology=="3-body",ThreeBodyDecaysEventsAtRest[LLP,SpecificProcess,mLLP,Nevents],If[Topology=="2-body",Block2BodyDistrAtRest[mLLP,productslist[[1]],productslist[[2]],Nevents],If[Topology=="4-body",FourBodyDecaysEventsAtRest[mLLP,productslist[[1]],productslist[[2]],productslist[[3]],productslist[[4]],Nevents]]]];*)
(*(*The iterative routine that checks if there are some unstable products, if yes - decays them, and defines the updated phase space*)*)
(*While[Times@@stabilitycheck[decayProductsTemp]==0.,*)
(*lenprod=Length[decayProductsTemp[[1]]]/LengthDataProduct;*)
(*Do[*)
(*(*Extracting the phase space of ith decay product*)*)
(*phasespaceproduct=decayProductsTemp[[All,Range[LengthDataProduct*(i-1)+1,LengthDataProduct*i]]];*)
(*(*Check if there are unstable particles among it*)*)
(*stab=Times@@stabilitycheck[phasespaceproduct];*)
(*(*If yes, then split it into sub-spaces of different products, decay unstable particles, then join it*)*)
(*If[stab==0.,*)
(*phasespacesplit=PhaseSpaceSplitter[phasespaceproduct];*)
(*Do[*)
(*If[phasespacesplit[[j]][[1]][[indexstability1]]==0.,*)
(*phasespacesplit[[j]]=PhaseSpaceStableFromUnstableBlock[phasespacesplit[[j]]];*)
(*]*)
(*,{j,1,Length[phasespacesplit]}];*)
(*phasespaceproduct=PadRight[Join[##]&@@phasespacesplit,Automatic,-999.]//Developer`ToPackedArray;*)
(*];*)
(*phasespacefin[i]=phasespaceproduct;*)
(*,{i,1,lenprod,1}];*)
(*decayProductsTemp=Join[##,2]&@@(phasespacefin[#]&/@Range[1,lenprod])//Developer`ToPackedArray;*)
(*];*)
(*decayProductsTemp*)
(*]*)


(* ::Input:: *)
(*ProcessesList["HNL-mixing-e","True"]*)


(* ::Input:: *)
(*PhaseSpaceDecaysRest["HNL-mixing-e",2.,"2\[Pi]l",10]*)


(* ::Section:: *)
(*Phase space of decay products - pre-simulated in pythia (for decays into jets)*)


(* ::Input:: *)
(*filespathsPS=FileNames["*.m",FileNameJoin[{NotebookDirectory[],"simulated phase space"}]];*)
(*filenamesPS=Table[Last@FileNameSplit@filespathsPS[[i]],{i,1,Length[filespathsPS],1}];*)
(*filenameparametersPS[i_]:=StringCases[filenamesPS[[i]],fip__~~"_"~~process__~~"_"~~mass__~~".m":>{fip,process,mass}][[1]]*)
(*filenamesparametersPS=Table[filenameparametersPS[i],{i,1,Length[filenamesPS],1}];*)
(*(*Phase space. It has the form of rows. Each row: the occurrence rate of the given final state, the final state phase space*)*)
(*Do[*)
(*PhaseSpaceDecaysRestJets[filenamesparametersPS[[i]][[1]],filenamesparametersPS[[i]][[2]],filenamesparametersPS[[i]][[3]]//ToExpression//N]=Import[FileNameJoin[{NotebookDirectory[],"simulated phase space",filenamesPS[[i]]}],"MX"],{i,1,Length[filenamesPS],1}];*)
(*ParsBL=Select[filenamesparametersPS,#[[1]]=="B-L"&];*)
(*(*For the moment, for B - XX mediators, the decay products sets are the same as for dark photons*)*)
(*Do[*)
(*PhaseSpaceDecaysRestJets[fip,ParsBL[[i]][[2]],ParsBL[[i]][[3]]//ToExpression//N]=PhaseSpaceDecaysRestJets[ParsBL[[i]][[1]],ParsBL[[i]][[2]],ParsBL[[i]][[3]]//ToExpression//N];*)
(*,{fip,{"B-3Lmu","B-3Le-Lmu+Ltau","B-Le-3Lmu+Ltau"}},{i,1,Length[ParsBL],1}]*)
(*(*Jet decays of ALPs coupled to fermions and gluons are the same - into two gluons. So the phase space is the same*)*)
(*ParsALPg=Select[filenamesparametersPS,#[[1]]=="ALP-gluon"&];*)
(*Do[PhaseSpaceDecaysRestJets["ALP-fermion",ParsALPg[[i]][[2]],ParsALPg[[i]][[3]]//ToExpression//N]=PhaseSpaceDecaysRestJets["ALP-gluon",ParsALPg[[i]][[2]],ParsALPg[[i]][[3]]//ToExpression//N];*)
(*,{fip,{"ALP-fermion"}},{i,1,Length[ParsALPg],1}];*)
(*(*Range of masses for which the phase space of decays into jets has been simulated*)*)
(*Do[mjetsrange[LLP]=Select[filenamesparametersPS,#[[1]]==LLP&][[All,3]]//ToExpression//N//Sort//DeleteDuplicates,{LLP,LLPlist}]*)
(*mjetsrange["HNL-mixing-mu"]=mjetsrange["HNL-mixing-tau"]=mjetsrange["HNL-mixing-e"];*)
(*mjetsrange["ALP-fermion"]=mjetsrange["ALP-gluon"];*)
(*mjetsrange["B-3Lmu"]=mjetsrange["B-3Le-Lmu+Ltau"]=mjetsrange["B-Le-3Lmu+Ltau"]=mjetsrange["B-L"];*)
(*ParsHNLe=Select[filenamesparametersPS,#[[1]]=="HNL-mixing-e"&&#[[2]]=="Jets-qqv"&];*)
(*Do[PhaseSpaceDecaysRestJets[fip,ParsHNLe[[i]][[2]],ParsHNLe[[i]][[3]]//ToExpression//N]=PhaseSpaceDecaysRestJets["HNL-mixing-e",ParsHNLe[[i]][[2]],ParsHNLe[[i]][[3]]//ToExpression//N];*)
(*,{fip,{"HNL-mixing-mu","HNL-mixing-tau"}},{i,1,Length[ParsHNLe],1}];*)


(* ::Section::Closed:: *)
(*Tests*)


(* ::Subsection::Closed:: *)
(*1. Checking if the angle between two massless decay products obtain from simulation matches theoretical formula*)


(* ::Input:: *)
(*Print["Decay products of LLP for test:"]*)
(*DecayTypeTest="e-pair"*)
(*Print["LLP mass for test:"]*)
(*MassParticleTest=4.*)
(*LengthTest=10^4;*)
(*ff=PhaseSpaceDecaysRest["Scalar",MassParticleTest,DecayTypeTest,LengthTest];*)
(*BoostedDataTest[ELLP_]:=Block[{},*)
(*\[Theta]vals=ArcCos[RandomReal[{-1,1},LengthTest]];*)
(*\[Phi]vals=RandomReal[{-Pi,Pi},LengthTest];*)
(*SpherePointsTemp=Table[{Cos[\[Phi]vals[[i]]]*Sin[\[Theta]vals[[i]]],Sin[\[Phi]vals[[i]]]*Sin[\[Theta]vals[[i]]],Cos[\[Theta]vals[[i]]]},{i,1,LengthTest,1}];*)
(*Join[{\[Sqrt](ELLP^2-MassParticleTest^2)#[[1]],\[Sqrt](ELLP^2-MassParticleTest^2)#[[2]],\[Sqrt](ELLP^2-MassParticleTest^2)#[[3]],ELLP,MassParticleTest}&/@SpherePointsTemp]*)
(*]*)
(*Print["LLP energy for test:"]*)
(*ELLPtest=18*)
(*BoostedDataTestGivenE=BoostedDataTest[ELLPtest];*)
(*BoostedDecayProductsTest=TabBoostedDecayProducts[BoostedDataTestGivenE,ff];*)
(*(*Block computing angle between two decay products for the given LLP energy, and polar/azimuthal angles at lab frame*)*)
(*ttt1=Table[ArcCos[(BoostedDecayProductsTest[[i]][[indexpx1]]*BoostedDecayProductsTest[[i]][[LengthDataProduct+indexpx1]]+BoostedDecayProductsTest[[i]][[indexpy1]]*BoostedDecayProductsTest[[i]][[LengthDataProduct+indexpy1]]+BoostedDecayProductsTest[[i]][[indexpz1]]*BoostedDecayProductsTest[[i]][[LengthDataProduct+indexpz1]])/(\[Sqrt](BoostedDecayProductsTest[[i]][[indexE1]]^2-BoostedDecayProductsTest[[i]][[indexm1]]^2)\[Sqrt](BoostedDecayProductsTest[[i]][[LengthDataProduct+indexE1]]^2-BoostedDecayProductsTest[[i]][[LengthDataProduct+indexm1]]^2))],{i,1,Length[BoostedDecayProductsTest],1}];*)
(*Histogram[ttt1]*)
(*Print["Min value of the angle \!\(\*SubscriptBox[\(\[Theta]\), \(product1, product2\)]\) between 2 decay products - simulation:"]*)
(*Min[ttt1]*)
(*Print["Min value of \[Theta] between 2 decay products - theory:"]*)
(*cos\[Theta]extr[E1_,ELLP_]=cos\[Theta]/.Solve[mfip^2==2*E1*(ELLP-E1)*(1-cos\[Theta]),cos\[Theta]][[1]];*)
(*E1extr[ELLP_]=E1/.Solve[D[cos\[Theta]extr[E1,ELLP],E1]==0,E1][[1]];*)
(*\[Theta]min2body[ELLP_,mfip_]=ArcCos[cos\[Theta]extr[E1extr[ELLP],ELLP]]*)
(*\[Theta]min2body[ELLPtest,MassParticleTest]*)
(*Clear[ELLPtest,MassParticleTest,ParamProductMass1,ParamProductMass2,ff]*)


(* ::Subsection::Closed:: *)
(*2. Checking that kinematics for 3-body decays *)


(* ::Subsubsection::Closed:: *)
(*Shape of the energy distributions matches analytic formula*)


(* ::Input:: *)
(*fipt="HNL-mixing-e";*)
(*proct="ee\[Nu]";*)
(*mass=0.02;*)
(*decprodlist=ListDecayProducts[fipt,proct];*)
(*pdgsDecayProd=ParamProductToPDGid[#]&/@decprodlist;*)
(*massesProd=ParamProductMass[#]&/@pdgsDecayProd;*)
(*phasespace=PhaseSpaceDecaysRest[fipt,mass,proct,10^6];*)
(*distr1[mLLP_,E1_,E3_]=Msquared3BodyLLP[fipt,proct,E1,E3, mLLP];*)
(*endistr1[mLLP_,E1_]=(Integrate[distr1[mLLP,E1,E3],E3]/.{E3->E3domain[E1,mLLP,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[2]]})-(Integrate[distr1[mLLP,E1,E3],E3]/.{E3->E3domain[E1,mLLP,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[1]]})//Simplify;*)
(*endistr3[mLLP_,E3_]=((Integrate[distr1[mLLP,E1,E3],E1]/.{E1->E1domain1Max[E3,mLLP,massesProd[[1]],massesProd[[2]],massesProd[[3]]]})-(Integrate[distr1[mLLP,E1,E3],E1]/.{E1->E1domain1Min[E3,mLLP,massesProd[[1]],massesProd[[2]],massesProd[[3]]]})//Simplify);*)
(*norm=NIntegrate[endistr1[mass,E1],{E1,E1domain[mass,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[1]],E1domain[mass,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[2]]}];*)
(*pt1=Show[LogLogPlot[1.2 endistr1[mass,E1]/norm,{E1,E1domain[mass,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[1]],E1domain[mass,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[2]]}],Histogram[phasespace[[All,indexE1]],1000,"ProbabilityDensity",ScalingFunctions->{"Log","Log"}]];*)
(*pt2=Show[LogLogPlot[1.2 endistr3[mass,E3]/norm,{E3,E3domain1[mass,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[1]],E3domain1[mass,massesProd[[1]],massesProd[[2]],massesProd[[3]]][[2]]}],Histogram[phasespace[[All,2*LengthDataProduct+indexE1]],1000,"ProbabilityDensity",ScalingFunctions->{"Log","Log"}]];*)
(*Style[Row[{pt1,pt2}],ImageSizeMultipliers->{1, 1}]*)


(* ::Subsubsection::Closed:: *)
(*4-momentum conservation*)


(* ::Input:: *)
(*fiptest="HNL-mixing-tau";*)
(*proctest="Jets-qql";*)
(*masstest=2.3;*)
(*pd=PhaseSpaceDecaysRest[fiptest,masstest,proctest,10];//AbsoluteTiming*)
(*fourcheck[j_]:=Sum[If[pd[[j]][[LengthDataProduct*(i-1)+indexpdg1]]!=-999.,pd[[j]][[LengthDataProduct*(i-1)+#]],0.],{i,1,Length[pd[[1]]]/LengthDataProduct,1}]&/@{indexpx1,indexpy1,indexpz1,indexE1}*)
(*Table[fourcheck[j],{j,1,Length[pd],1}]*)


(* ::Subsection::Closed:: *)
(*Checking the 4-momentum conservation for the phase space simulated in pythia*)


(* ::Input:: *)
(*keysjets=Keys[DownValues@PhaseSpaceDecaysRestJets][[All,1,#]]&/@{1,2,3}//Transpose;*)
(*pssum=Hold@Compile[{{tab,_Real,2},{mass,_Real}},*)
(*Module[{len,px=0.,py=0.,pz=0.,e=0.,en=0.,jmax=0,checker=0.},*)
(*len=Length[tab[[1]]]/LengthDataProduct;*)
(*Do[*)
(*jmax=0;*)
(*Do[If[Compile`GetElement[tab,k,(j-1)LengthDataProduct+indexpdg1]==-999.,Break[],jmax+=1],{j,1,len,1}];*)
(*e=Sum[Compile`GetElement[tab,k,(j-1)LengthDataProduct+indexE1],{j,1,jmax,1}];*)
(*px=Sum[Compile`GetElement[tab,k,(j-1)LengthDataProduct+indexpx1],{j,1,jmax,1}];*)
(*py=Sum[Compile`GetElement[tab,k,(j-1)LengthDataProduct+indexpy1],{j,1,jmax,1}];*)
(*pz=Sum[Compile`GetElement[tab,k,(j-1)LengthDataProduct+indexpz1],{j,1,jmax,1}];*)
(*checker=Max[checker,Max[Abs[e-mass],Abs[px],Abs[py],Abs[pz]]];*)
(*,{k,1,Length[tab],1}];*)
(*checker*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}]/.ruleOwn[{indexpx1,indexpy1,indexpz1,indexE1,LengthDataProduct,indexpdg1}]//ReleaseHold*)
(*momconscheck[i_]:=Module[{dat,len},*)
(*dat=PhaseSpaceDecaysRestJets[keysjets[[i]][[1]],keysjets[[i]][[2]],keysjets[[i]][[3]]];*)
(*{keysjets[[i]][[1]],keysjets[[i]][[2]],keysjets[[i]][[3]],pssum[dat,keysjets[[i]][[3]]]}*)
(*]*)
(*checktab=Table[momconscheck[i],{i,1,Length[keysjets],1}];//AbsoluteTiming*)
(*If[Max[checktab[[All,4]]]>10^-5.,infoDialog["The simulated phase space does not obey 4-momentum conservation! Examine in detail"]]*)


(* ::Chapter::Closed:: *)
(*Geometry of different experiments and cross-sections*)


(* ::Input:: *)
(*NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/experiments.nb"}]]*)


(* ::Title::Closed:: *)
(*Selecting the experiment*)


(* ::Chapter::Closed:: *)
(*Choosing the experiment*)


(* ::Input:: *)
(*SetDirectory[NotebookDirectory[]];*)
(*Print["List of experiments with implemented geometry:"]*)
(*experimentlist=Keys[DownValues[FacilityExperiment]][[All,1,1]](*Keys[DetectorPlaneOrientation]//Sort*);*)
(*Join[Table[{i},{i,1,Length[experimentlist],1}],{experimentlist}//Transpose,2]//TableForm*)
(*Print["Selected experiment:"]*)
(*DynamicModule[{choice=None,options,rows,cols,gridButtons,maxWidth,paneHeight},options=experimentlist;(*Replace with your actual list items*)cols=3;(*Number of columns in the grid*)rows=Ceiling[Length[options]/cols];(*Number of rows*)gridButtons=Partition[PadRight[options,rows*cols,""],cols];*)
(*(*Estimate the width of the widest button*)maxWidth=Max[StringLength/@ToString/@options]*5;(*Adjust multiplier as needed*)(*Set the height of the pane*)paneHeight=300;(*Adjust this value based on desired height*)GivenExperiment=DialogInput[Column[{TextCell["Choose the experiment:"],Pane[Dynamic@Grid[Table[With[{opt=gridButtons[[i,j]]},Button[opt,choice=opt,Background->If[choice===opt,LightBlue,None],ImageSize->{maxWidth,Automatic} (*Set width to maxWidth*)]],{i,rows},{j,cols}],Spacings->{2,2}],{Automatic,paneHeight},Scrollbars->{False,True}],Button["OK",DialogReturn[choice],ImageSize->Automatic]}]]]*)
(*If[MemberQ[explistanub,GivenExperiment]==True,*)
(*infoDialog["One of the decay volumes of ANUBIS-shaft has been selected. The full sensitivity requires calculating the acceptances for all the three volumes. You need to generate them afterwards"]]*)


(* ::Section:: *)
(*Setting all the parameters*)


(* ::Input:: *)
(*FacilityGivenExperiment=FacilityExperiment[GivenExperiment];*)
(*EmaxGivenExperiment=EmaxFacility[FacilityGivenExperiment];*)
(*ECALoptionGivenExperiment=ECALoptionExperiment[GivenExperiment];*)
(*DipoleMagnetOptionGivenExperiment=DipoleMagnetOptionExperiment[GivenExperiment];*)
(*(*Decay volume as detector: True, False*)*)
(*DecayVolumeAsDetectorGivenExperiment=DecayVolumeAsDetectorExperiment[GivenExperiment];*)
(*(*Default list of detectable decay products at the given experiment*)*)
(*DetectablePDGsGivenExperiment=DetectablePDGsExperiment[GivenExperiment]//Sort;*)
(*(*___________________________________________________________*)*)
(*(*Box, Cylinder, Annular cylinder*)*)
(*GeometryGivenExperiment=GeometryExperiment[GivenExperiment];*)
(*(*Beam, Transverse*)*)
(*DetectorPlaneOrientationGivenExperiment=DetectorPlaneOrientationExperiment[GivenExperiment];*)
(*(*Decay volume parameters*)*)
(*xToDecayVolumeCenterGivenExperiment[z_]=xToDecayVolumeCenterExperiment[z,GivenExperiment];*)
(*yToDecayVolumeCenterGivenExperiment[z_]=yToDecayVolumeCenterExperiment[z,GivenExperiment];*)
(*dxDecayVolumeGivenExperiment[z_]=dxDecayVolumeExperiment[z,GivenExperiment];*)
(*dyDecayVolumeGivenExperiment[z_]=dyDecayVolumeExperiment[z,GivenExperiment];*)
(*zToDecayVolumeGivenExperiment=zToDecayVolumeExperiment[GivenExperiment];*)
(*dzFidGivenExperiment=dzDecayVolumeExperiment[GivenExperiment];*)
(*zMaxDecayVolumeGivenExperiment=zMaxDecayVolumeExperiment[GivenExperiment];*)
(*xLongMaxDetectorGivenExperiment=xLongMaxDetectorExperiment[GivenExperiment];*)
(*dxDecayVolumeGivenExperimentMax=dxDecayVolumeGivenExperiment[zMaxDecayVolumeGivenExperiment];*)
(*dyDecayVolumeGivenExperimentMax=dyDecayVolumeGivenExperiment[zMaxDecayVolumeGivenExperiment];*)
(*RinnerDecayVolumeGivenExperiment[z_]=RinnerDecayVolumeExperiment[GivenExperiment,z];*)
(*RouterDecayVolumeGivenExperiment[z_]=RouterDecayVolumeExperiment[GivenExperiment,z];*)
(*DecayVolumeGeometryGivenExperiment=DecayVolumeGeometry[GivenExperiment];*)
(*(*Detector parameters*)*)
(*dxDetectorGivenExperiment[z_]=dxDetectorExperiment[GivenExperiment,z];*)
(*dyDetectorGivenExperiment[z_]=dyDetectorExperiment[GivenExperiment,z];*)
(*dzDetectorGivenExperiment=dzDetectorExperiment[GivenExperiment];*)
(*dx2PerpDetectorGivenExperiment[z_]=If[DetectorPlaneOrientationGivenExperiment=="Transverse",dyDetectorGivenExperiment[z],dzDetectorGivenExperiment];*)
(*{xToDetectorCenterGivenExperiment,yToDetectorCenterGivenExperiment,zToDetectorCenterGivenExperiment}=(Symbol[#<>"ToDetectorCenterExperiment"][GivenExperiment]//N)&/@{"x","y","z"};*)
(*x2PerpToDetectorCenterGivenExperiment=If[DetectorPlaneOrientationGivenExperiment=="Transverse",yToDetectorCenterGivenExperiment,zToDetectorCenterGivenExperiment];*)
(*{RinnerDetectorGivenExperiment[z_],RouterDetectorGivenExperiment[z_]}={RinnerDetectorExperiment[GivenExperiment,z],RouterDetectorExperiment[GivenExperiment,z]};*)
(*(*____________________________________________________*)*)
(*(*Given experiment boundaries*)*)
(*(*____________________________________________________*)*)
(*GivenExperimentBoundaries=\[Theta]minmaxBlock[GivenExperiment];*)
(*(*Min/max polar angles of the decay volume and detector, and the corresponding points*)*)
(*{ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax}={GivenExperimentBoundaries[[1]][[2]][[1]],GivenExperimentBoundaries[[1]][[2]][[2]]}//N;*)
(*{R\[Theta]minDecayVolume,R\[Theta]maxDecayVolume}={GivenExperimentBoundaries[[1]][[1]][[1]],GivenExperimentBoundaries[[1]][[1]][[2]]};*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",*)
(*{ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}={GivenExperimentBoundaries[[2]][[2]][[1]],GivenExperimentBoundaries[[2]][[2]][[2]]}//N;*)
(*{R\[Theta]minEndDetector,R\[Theta]maxEndDetector}={GivenExperimentBoundaries[[2]][[1]][[1]],GivenExperimentBoundaries[[2]][[1]][[2]]}//N;*)
(*DetectorGeometryGivenExperiment=DetectorGeometry[GivenExperiment],*)
(*{ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}={ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax}*)
(*];*)
(*FinalPlaneGivenExperiment=PlaneEndOfDetectorExperiment[GivenExperiment];*)
(*(*Parameters of the dipole magnet in the spectrometer (if present)*)*)
(*zMagnetMinGivenExperiment=zMagnetMinExperiment[GivenExperiment];*)
(*zMagnetMaxGivenExperiment=zMagnetMaxExperiment[GivenExperiment];*)
(*Bval=If[DipoleMagnetOptionGivenExperiment=="False",0,MagneticFieldExperiment[GivenExperiment]];*)
(*(*ECAL position*)*)
(*ECALpositionGivenExperiment=zECALminExperiment[GivenExperiment];*)
(*(*FinalPlaneGivenExperiment=If[finalPlaneGivenExperiment\[Equal]"EndOfDetector",EndOfDetectorGivenExperiment,PlaneDetectorGivenExperiment];*)*)
(*TableParticlesNumbersGivenExperiment=TableNumbersParticlesExperiment[GivenExperiment];*)
(*xLongMuonPlaneGivenExperiment=xLongMuonPlaneExperiment[GivenExperiment];*)
(*xLongNonMuonPlaneGivenExperiment=xLongNonMuonPlaneExperiment[GivenExperiment];*)
(*(*Geometric conditions*)*)
(*IfLLPinsideDecVol[zLLP_,xLLP_,yLLP_]=IfLLPinsideDecVol[zLLP,xLLP,yLLP,GivenExperiment];*)
(*{IfLLPtoDet[x1LLPproj_,x2LLPproj_,xLongProj_],IfLLPnotToDet[x1LLPproj_,x2LLPproj_,xLongProj_]}={IfLLPtoDet[x1LLPproj,x2LLPproj,xLongProj,GivenExperiment],IfLLPnotToDet[x1LLPproj,x2LLPproj,xLongProj,GivenExperiment]};*)
(*IfLLPdecVolToDet[zLLP_,xLLP_,yLLP_,x1LLPproj_,x2LLPproj_,xLongProj_]=IfLLPdecVolToDet[zLLP,xLLP,yLLP,x1LLPproj,x2LLPproj,xLongProj,GivenExperiment];*)
(*IfLLPdecVolNotToDet[zLLP_,xLLP_,yLLP_,x1LLPproj_,x2LLPproj_,xLongProj_]=IfLLPdecVolNotToDet[zLLP,xLLP,yLLP,x1LLPproj,x2LLPproj,xLongProj,GivenExperiment];*)
(*DecayAcceptanceGeometry[x1LLPproj_,x2LLPproj_,xLongProj_]=IfLLPtoDet[x1LLPproj,x2LLPproj,xLongProj];*)


(* ::Chapter::Closed:: *)
(*Specifying cuts on the decay products*)


(* ::Input:: *)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(**)
(*(*filenameGivenExperiment=filenameExperiment[finalPlaneGivenExperiment,GivenExperiment];*)
(*filenameGivenExperimentzN=filenameExperimentzN[finalPlaneGivenExperiment,GivenExperiment]*)*)
(*{{"Experiment","Facility","Decay volume as detector","If ECAL is present","If dipole magnet is present","\!\(\*SubscriptBox[\(E\), \(LLP, max\)]\)"},{GivenExperiment,FacilityGivenExperiment,DecayVolumeAsDetectorGivenExperiment,ECALoptionGivenExperiment,DipoleMagnetOptionGivenExperiment,EmaxGivenExperiment}}//TableForm*)
(*(*WhetherCutsTemp=dropdownDialog[{"Yes","No"},"Would you like to impose any cuts on acceptance of decay products other than geometric?"];*)
(*WhetherCuts=If[WhetherCutsTemp\[Equal]"Yes",1,0];*)*)
(*(*____________________________________________________*)*)
(*(*Imposing cuts on decay products*)*)
(*(*____________________________________________________*)*)
(*pTcutLowerZero=0.;*)
(*pTcutUpperZero=10^10.;*)
(*eCutLowerZero=0.;*)
(*eCutUpperZero=10^10.;*)
(*IPcutZero=10^10.;*)
(*AngSepCutZero=0.;*)
(*SScutZero=0.;*)
(*minvCutLowerZero=0.;*)
(*minvCutUpperZero=10^10.;*)
(*eTotCutLowerZero=0.;*)
(*eTotCutUpperZero=10^10.;*)
(*{pTelCutLower,pTelCutUpper,pT\[Mu]CutLower,pT\[Mu]CutUpper,pThadrCutLower,pThadrCutUpper,eElCutLower,eElCutUpper,e\[Mu]CutLower,e\[Mu]CutUpper,eHadrCutLower,eHadrCutUpper,EtotElCutLower,EtotElCutUpper,Etot\[Mu]CutLower,Etot\[Mu]CutUpper,EtotHadrCutLower,EtotHadrCutUpper,EtotMixedCutLower,EtotMixedCutUpper,e\[Gamma]CutLower,e\[Gamma]CutUpper,eh0CutLower,eh0CutUpper,Etot\[Gamma]\[Gamma]CutLower,Etot\[Gamma]\[Gamma]CutUpper,Etoth0h0CutLower,Etoth0h0CutUpper,EtotMixedNeutralCutLower,EtotMixedNeutralCutUpper,IPcut,AngSepCut,AngSepCutCharged,SScutCharged,SScutNeutral,minvElCutLower,minvElCutUpper,minv\[Mu]CutLower,minv\[Mu]CutUpper,minvHadrCutLower,minvHadrCutUpper,minvMixedCutLower,minvMixedCutUpper,minv\[Gamma]\[Gamma]CutLower,minv\[Gamma]\[Gamma]CutUpper,minvh0h0CutLower,minvh0h0CutUpper,minvMixedNeutralCutLower,minvMixedNeutralCutUpper}//Clear;*)
(*choice={"All"};*)
(*DynamicModule[{inputValues,labels,symbols,inputFields,submitButton},*)
(*labels={"Min/max \!\(\*SubscriptBox[\(p\), \(T\)]\) range of each charged decay product, in the form {\!\(\*SubscriptBox[\(p\), \(T, min\)]\), \!\(\*SubscriptBox[\(p\), \(T, max\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\(\(/\)\(-\)\)\)]\), (1st bracket), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\(\(/\)\(-\)\)\)]\) (2nd), hadrons \!\(\*SuperscriptBox[\(h\), \(+\(\(/\)\(-\)\)\)]\) (3rd)","Min/max energy of each charged decay product, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\(\(/\)\(-\)\)\)]\) (1st bracket), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\(\(/\)\(-\)\)\)]\) (2nd), \!\(\*SuperscriptBox[\(h\), \(+\(\(/\)\(-\)\)\)]\) (3rd)","Min/max total energy of two charged products, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\)]\)\!\(\*SuperscriptBox[\(e\), \(-\)]\) (1st bracket), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\) (2nd), \!\(\*SuperscriptBox[\(h\), \(+\)]\)\!\(\*SuperscriptBox[\(h\), \(-\)]\) (3rd), and mixed (4th)","Min/max energy of each neutral product, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \[Gamma] (1st bracket) and neutral hadrons \!\(\*SuperscriptBox[\(h\), \(0\)]\) (2nd)","Min/max total energy of a neutral pair, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \[Gamma]\[Gamma] (1st), \!\(\*SuperscriptBox[\(h\), \(0\)]\)\!\(\*SuperscriptBox[\(h\), \(0\)]\) (2nd), mixed (3rd)","Transerse impact parameter cut from above for charged tracks (in m)","Angular cut from below for photons/charged particles (in radians)",*)
(*"Transverse spatial separation cut from below for photons/charged particles (in m)","Enter the lower and upper invariant mass cut for the two charged products, in the form {\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\), \!\(\*SubscriptBox[\(m\), \(inv, upper\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\)]\)\!\(\*SuperscriptBox[\(e\), \(-\)]\) (1st), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\) (2nd), \!\(\*SuperscriptBox[\(h\), \(+\)]\)\!\(\*SuperscriptBox[\(h\), \(-\)]\) (3rd), mixed (4th)","Enter the lower and upper invariant mass cut for the two neutral products, in the form {\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\), \!\(\*SubscriptBox[\(m\), \(inv, upper\)]\)}, in the form {\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\), \!\(\*SubscriptBox[\(m\), \(inv, upper\)]\)}, for \[Gamma]\[Gamma] (1st), \!\(\*SuperscriptBox[\(h\), \(0\)]\)\!\(\*SuperscriptBox[\(h\), \(0\)]\) (2nd), mixed (3rd)"};*)
(*inputValues=zeros={{{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999}},-999,{-999,-999},{-999,-999},{{-999,-999},{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999}}}; *)
(*symbols={{{pTelCutLower,pTelCutUpper},{pT\[Mu]CutLower,pT\[Mu]CutUpper},{pThadrCutLower,pThadrCutUpper}},{{eElCutLower,eElCutUpper},{e\[Mu]CutLower,e\[Mu]CutUpper},{eHadrCutLower,eHadrCutUpper}},{{EtotElCutLower,EtotElCutUpper},{Etot\[Mu]CutLower,Etot\[Mu]CutUpper},{EtotHadrCutLower,EtotHadrCutUpper},{EtotMixedCutLower,EtotMixedCutUpper}},{{e\[Gamma]CutLower,e\[Gamma]CutUpper},{eh0CutLower,eh0CutUpper}},{{Etot\[Gamma]\[Gamma]CutLower,Etot\[Gamma]\[Gamma]CutUpper},{Etoth0h0CutLower,Etoth0h0CutUpper},{EtotMixedNeutralCutLower,EtotMixedNeutralCutUpper}},IPcut,{AngSepCut,AngSepCutCharged},{SScutCharged,SScutNeutral},{{minvElCutLower,minvElCutUpper},{minv\[Mu]CutLower,minv\[Mu]CutUpper},{minvHadrCutLower,minvHadrCutUpper},{minvMixedCutLower,minvMixedCutUpper}},{{minv\[Gamma]\[Gamma]CutLower,minv\[Gamma]\[Gamma]CutUpper},{minvh0h0CutLower,minvh0h0CutUpper},{minvMixedNeutralCutLower,minvMixedNeutralCutUpper}}};*)
(*zerosvalues={{{pTcutLowerZero,pTcutUpperZero},{pTcutLowerZero,pTcutUpperZero},{pTcutLowerZero,pTcutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},IPcutZero,{AngSepCutZero,AngSepCutZero},{SScutZero,SScutZero},{{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero}},{{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero}}};*)
(*If[Length[inputValues]!=Length[labels]!=Length[symbols],MessageDialog["Error: The number of initial values does not match the number of labels."];*)
(*Abort[]];*)
(*productionSelector=Column[{Style["Select the particles that are detectable at " <>GivenExperiment<>":",Bold],TogglerBar[Dynamic[choice],Join[{"All"},ParamPDGidToProduct[#]&/@(Abs[DetectablePDGsGivenExperiment]//DeleteDuplicates)],Appearance->"Horizontal"->{5,20}]}];*)
(*inputFields=Table[With[{i=i},Column[{labels[[i]]<>":",InputField[Dynamic[inputValues[[i]]],Expression,FieldSize->{40,Automatic}]}]],{i,Length[labels]}];*)
(*introphr={Style["Impose the cuts on decay products. If the given cut should not be imposed enter -999 for each value (default choice). All the energy/\!\(\*SubscriptBox[\(p\), \(T\)]\) cuts are in GeV",Bold]};*)
(*submitButton=Button["Submit",Evaluate[Sequence@@Flatten[MapThread[Set,{Flatten[symbols],MapThread[If[#1===#2,#3,#1]&,{Flatten[inputValues],Flatten[zeros],Flatten[zerosvalues]}]}]]]; DialogReturn[Null],ImageSize->Automatic];*)
(*(*submitButton=Button["Submit",Evaluate[Sequence@@Flatten[MapThread[Set,{Flatten[symbols,1],Flatten[inputValues,1]}]]]; DialogReturn[Null],ImageSize->Automatic];*)*)
(*DialogInput[Column[Flatten[{productionSelector,introphr," ",inputFields,submitButton}]]]*)
(*];*)
(*If[choice=={}||MemberQ[choice,"All"],choice={"All"}];*)
(*If[choice!={"All"},*)
(*DetectablePDGsGivenExperimentTemp=Join[ParamProductToPDGid[#]&/@choice,-ParamProductToPDGid[#]&/@choice];*)
(*DetectablePDGsGivenExperiment=Select[DetectablePDGsGivenExperimentTemp,FreeQ[ParamPDGidToProduct[#],Missing]&]//N//Sort;*)
(*];*)
(*Print["List of PDGs of detectable particles:"]*)
(*DetectablePDGsGivenExperiment*)


(* ::Section:: *)
(*Displaying cuts*)


(* ::Subsection:: *)
(*Creating functions with cuts*)


(* ::Input:: *)
(*createCompiledFunctionpT[zeroValue_,elcut_,\[Mu]cut_,hadrcut_]:=Hold@Compile[{{id,_Real},{charge,_Real}},Module[{cut,absid},*)
(*cut=zeroValue;*)
(*absid=Abs[id];*)
(*If[charge!=0.,*)
(*cut=If[absid==11.,elcut,If[absid==13.,\[Mu]cut,hadrcut]];*)
(*];*)
(*cut*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]//ReleaseHold*)
(*pTcutLowerID=createCompiledFunctionpT[pTcutLowerZero,pTelCutLower,pT\[Mu]CutLower,pThadrCutLower];*)
(*pTcutUpperID=createCompiledFunctionpT[pTcutUpperZero,pTelCutUpper,pT\[Mu]CutUpper,pThadrCutUpper];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@pTcutLowerID;*)
(*createCompiledFunctionE[zeroValue_,\[Gamma]cut_,h0cut_,elcut_,\[Mu]cut_,hadrcut_]:=Hold@Compile[{{id,_Real},{charge,_Real}},Module[{cut,absid},*)
(*cut=zeroValue;*)
(*absid=Abs[id];*)
(*If[charge==0.,*)
(*cut=If[absid==22.,\[Gamma]cut,h0cut];*)
(*];*)
(*If[charge!=0.,*)
(*cut=If[absid==11.,elcut,If[absid==13.,\[Mu]cut,hadrcut]];*)
(*];*)
(*cut*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]//ReleaseHold*)
(*ecutLowerID=createCompiledFunctionE[eCutLowerZero,e\[Gamma]CutLower,eh0CutLower,eElCutLower,e\[Mu]CutLower,eHadrCutLower];*)
(*ecutUpperID=createCompiledFunctionE[eCutUpperZero,e\[Gamma]CutUpper,eh0CutUpper,eElCutUpper,e\[Mu]CutUpper,eHadrCutUpper];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@ecutLowerID;*)
(*createCompiledFunction[zeroValue_,h0h0Cut_,gammaGammaCut_,mixedNeutralCut_,hadrCut_,muCut_,elCut_,mixedCut_]:=Hold@Compile[{{id1,_Real},{charge1,_Real},{id2,_Real}},Module[{cut,absid1,absid2,condel1,condel2,condMu1,condMu2},cut=zeroValue;*)
(*absid1=Abs[id1];*)
(*absid2=Abs[id2];*)
(*If[charge1==0.,*)
(*cut=If[id2!=id1,mixedNeutralCut,If[id1==22.,gammaGammaCut,h0h0Cut]];*)
(*];*)
(*If[charge1!=0.,*)
(*{condel1,condel2}={If[absid1==11.,1.,0.],If[absid2==11.,1.,0.]};*)
(*{condMu1,condMu2}={If[absid1==13.,1.,0.],If[absid2==13.,1.,0.]};*)
(*cut=If[condel1+condel2+condMu1+condMu2==0.,hadrCut,If[Max[condel1*condel2,condMu1*condMu2]==0.,mixedCut,If[condel1*condel2==1.,elCut,muCut]]];*)
(*];*)
(*cut],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True](*/. ruleOwn[{zeroValue,h0h0Cut,gammaGammaCut,mixedNeutralCut,hadrCut,muCut,elCut,mixedCut}]*)//ReleaseHold;*)
(*EtotCutLowerID=createCompiledFunction[eTotCutLowerZero,Etoth0h0CutLower,Etot\[Gamma]\[Gamma]CutLower,EtotMixedNeutralCutLower,EtotHadrCutLower,Etot\[Mu]CutLower,EtotElCutLower,EtotMixedCutLower];*)
(*EtotCutUpperID=createCompiledFunction[eTotCutUpperZero,Etoth0h0CutUpper,Etot\[Gamma]\[Gamma]CutUpper,EtotMixedNeutralCutUpper,EtotHadrCutUpper,Etot\[Mu]CutUpper,EtotElCutUpper,EtotMixedCutUpper];*)
(*minvCutLowerID=createCompiledFunction[minvCutLowerZero,minvh0h0CutLower,minv\[Gamma]\[Gamma]CutLower,minvMixedNeutralCutLower,minvHadrCutLower,minv\[Mu]CutLower,minvElCutLower,minvMixedCutLower];*)
(*minvCutUpperID=createCompiledFunction[minvCutUpperZero,minvh0h0CutUpper,minv\[Gamma]\[Gamma]CutUpper,minvMixedNeutralCutUpper,minvHadrCutUpper,minv\[Mu]CutUpper,minvElCutUpper,minvMixedCutUpper];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@EtotCutUpperID;*)
(*AngSepCutID=Hold@Compile[{{id1,_Real},{id2,_Real}},*)
(*If[id1==22.||id1==130.,AngSepCut,AngSepCutCharged],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{AngSepCut,AngSepCutZero,AngSepCutCharged}]//ReleaseHold;*)
(*SScutID=Hold@Compile[{{id1,_Real},{id2,_Real}},*)
(*If[id1==22.||id1==130.,SScutNeutral,SScutCharged],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{SScutNeutral,SScutZero,SScutCharged}]//ReleaseHold;*)
(*IPcutID=Hold@Compile[{{id1,_Real},{id2,_Real}},*)
(*If[id1!=22.&&id1!=2112.&&id1!=130.,IPcut,IPcutZero],CompilationTarget->"C",RuntimeAttributes->{Listable},RuntimeOptions->"Speed",Parallelization->True]/.ruleOwn[{IPcut,IPcutZero}]//ReleaseHold*)


(* ::Subsection:: *)
(*Visualization of the cuts*)


(* ::Input:: *)
(*tabbcuts=SortBy[Select[Flatten[Table[{id1,id2,ParamPDGidToProduct[id1],ParamPDGidToProduct[id2],ParamProductCharge[id1],ParamProductCharge[id2],ecutLowerID[id1//N,ParamProductCharge[id1]//N],ecutUpperID[id1//N,ParamProductCharge[id1]//N],pTcutLowerID[id1//N,ParamProductCharge[id1]],pTcutUpperID[id1//N,ParamProductCharge[id1]//N],EtotCutLowerID[id1//N,ParamProductCharge[id1]//N,id2//N],EtotCutUpperID[id1//N,ParamProductCharge[id1]//N,id2//N],IPcutID[id1//N,id2//N],AngSepCutID[id1//N,id2//N],SScutID[id1//N,id2//N],minvCutLowerID[id1//N,ParamProductCharge[id1]//N,id2//N],minvCutUpperID[id1//N,ParamProductCharge[id1]//N,id2//N]},{id1,detectablepdgs},{id2,detectablepdgs}],1],#[[5]]+#[[6]]==0&&#[[1]]<=#[[2]]&],{#[[1]],#[[2]]&}];*)
(*cutsmeaning={"\!\(\*SubscriptBox[\(pdg\), \(1\)]\)","\!\(\*SubscriptBox[\(pdg\), \(2\)]\)","\!\(\*SubscriptBox[\(id\), \(1\)]\)","\!\(\*SubscriptBox[\(id\), \(2\)]\)","\!\(\*SubscriptBox[\(Q\), \(prod, 1\)]\)","\!\(\*SubscriptBox[\(Q\), \(prod, 2\)]\)","\!\(\*SubscriptBox[\(E\), \(min, 1\)]\) (GeV)","\!\(\*SubscriptBox[\(E\), \(max, 1\)]\) (GeV)","\!\(\*SubscriptBox[\(p\), \(T, min, 1\)]\) (GeV)","\!\(\*SubscriptBox[\(p\), \(T, max, 1\)]\) (GeV)","\!\(\*FractionBox[SubscriptBox[\(E\), \(min, 1 + 2\)], \(GeV\)]\)","\!\(\*FractionBox[SubscriptBox[\(E\), \(max, 1 + 2\)], \(GeV\)]\)","IP cut (m)","angular separation cut (rad)","Transverse spatial separation cut (m)","\!\(\*SubscriptBox[\(m\), \(inv, min\)]\) (GeV)","\!\(\*SubscriptBox[\(m\), \(inv, max\)]\) (GeV)"};*)
(*Join[{Range[1,Length[cutsmeaning]],cutsmeaning},tabbcuts]//TableForm*)
(*IfEcuts=If[Length[Select[tabbcuts,#[[7]]!=eCutLowerZero||#[[8]]!=eCutUpperZero||#[[11]]!=eTotCutLowerZero||#[[12]]!=eTotCutUpperZero&]]==0,0,1];*)
(*IfEtotLowercuts=If[Length[Select[tabbcuts,#[[11]]!=eTotCutLowerZero&]]==0,0,1];*)
(*IfEtotUppercuts=If[Length[Select[tabbcuts,#[[12]]!=eTotCutUpperZero&]]==0,0,1];*)
(*IfpTcuts=If[Length[Select[tabbcuts,#[[9]]!=pTcutLowerZero||#[[10]]!=pTcutUpperZero&]]==0,0,1];*)
(*IfAngSepCuts=If[Length[Select[tabbcuts,#[[14]]!=AngSepCutZero&]]==0,0,1];*)
(*IfSScuts=If[Length[Select[tabbcuts,#[[15]]!=AngSepCutZero&]]==0,0,1];*)
(*IfIPcuts=If[Length[Select[tabbcuts,#[[13]]!=IPcutZero&]]==0,0,1];*)
(*IfminvCuts=If[Length[Select[tabbcuts,#[[16]]!=minvCutLowerZero||#[[17]]!=minvCutUpperZero&]]==0,0,1];*)
(*IfminvLowerCuts=If[Length[Select[tabbcuts,#[[16]]!=minvCutLowerZero&]]==0,0,1];*)
(*IfminvUpperCuts=If[Length[Select[tabbcuts,#[[17]]!=minvCutUpperZero&]]==0,0,1];*)
(*WhetherCuts=If[Total[{IfEcuts,IfEtotLowercuts,IfEtotUppercuts,IfpTcuts,IfAngSepCuts,IfIPcuts,IfminvCuts,IfminvLowerCuts,IfminvUpperCuts}]==0,0.,1.];*)
(*{{"Any E cut","Tot \!\(\*SubscriptBox[\(E\), \(lower\)]\) cut","Tot \!\(\*SubscriptBox[\(E\), \(upper\)]\) cut","\!\(\*SubscriptBox[\(p\), \(T\)]\) cut","Angular cut","SS cut","IP cuts","Any \!\(\*SubscriptBox[\(m\), \(inv\\\  cut\)]\)","\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\) cuts","\!\(\*SubscriptBox[\(m\), \(inv, upper\)]\) cuts"},{IfEcuts,IfEtotLowercuts,IfEtotUppercuts,IfpTcuts,IfAngSepCuts,IfSScuts,IfIPcuts,IfminvCuts,IfminvLowerCuts,IfminvUpperCuts}}//TableForm*)


(* ::Section:: *)
(*Refining possible decay channels*)


(* ::Input:: *)
(*Do[*)
(*ProcessesListRefined[LLP,ECALoptionGivenExperiment]=ProcessesList[LLP,ECALoptionGivenExperiment];*)
(*,{LLP,LLPlist}]*)
(*If[MemberQ[{"CHARM-lepton","CHARM-approx-lepton","BEBC"},GivenExperiment]==True,*)
(*relevantprocesses={{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"}};*)
(*If[MemberQ[{"BEBC"},GivenExperiment]==True,relevantprocesses=Join[relevantprocesses,{{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null","Null"}{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Nu]","Null","Null"},{"\[Gamma]","\[Gamma]","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Gamma]","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"}}]];*)
(*Do[*)
(*ProcessesListRefined[LLP,ECALoptionGivenExperiment]=Select[ProcessesList[LLP,ECALoptionGivenExperiment],MemberQ[Sort/@relevantprocesses,Sort[ListDecayProducts[LLP,#]]]==True&];*)
(*,{LLP,LLPlist}]*)
(*]*)


(* ::Chapter::Closed:: *)
(*Azimuthal acceptance calculation*)


(* ::Section:: *)
(*Geometry visualization*)


(* ::Input:: *)
(*Print["List of geometric parameters:"]*)
(*If[GeometryGivenExperiment=="Cylinder"||GeometryGivenExperiment=="Annular cylinder",{{"Orientation of the detector cross section wrt beamline","Decay volume geometry type","\!\(\*FractionBox[SubscriptBox[\(l\), \(to\\\  fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid + det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(inner, dec\\\  vol\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(outer, dec\\\  vol\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(inner, det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(outer, det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, det\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, det\)], \(rad\)]\)"},{DetectorPlaneOrientationGivenExperiment,GeometryGivenExperiment,zToDecayVolumeGivenExperiment,dzFidGivenExperiment,xLongMaxDetectorGivenExperiment,RinnerDecayVolumeGivenExperiment[z],RouterDecayVolumeGivenExperiment[z],RinnerDetectorGivenExperiment,RouterDetectorGivenExperiment,ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax,ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}}//TableForm,{{"Orientation of the detector cross section wrt beamline","Decay volume geometry type","\!\(\*FractionBox[SubscriptBox[\(l\), \(to\\\  fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid + det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(1\\\  dec . vol . \)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(2\\\  dec . vol . \)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(1 \( \(det\)\(.\)\)\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(2 \( \(det\)\(.\)\)\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, det\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, det\)], \(rad\)]\)"},{DetectorPlaneOrientationGivenExperiment,GeometryGivenExperiment,zToDecayVolumeGivenExperiment,dzFidGivenExperiment,xLongMaxDetectorGivenExperiment,dxDecayVolumeGivenExperiment[z],dyDecayVolumeGivenExperiment[z],dxDetectorGivenExperimentMax,dyDetectorGivenExperimentMax,ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax,ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}}//TableForm]*)
(*Print["Experiment geometry. Black point - collision point. The blue domain - decay volume. The red domain - detector. The green plane - final plane:"]*)
(*(*Block defining relevant plots*)*)
(*ExperimentPlots:=Block[{},*)
(*BoxRatioz=3;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes->True,AxesLabel->{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin->{0,0,0},ViewProjection->"Orthographic",ViewCenter->{0,0,0},ViewPoint->{-0.7,0.25,-2},ViewVertical->{0,1,0},BoxRatios->{1,1,BoxRatioz},AxesStyle->{Thickness[0.03]},LabelStyle->{Directive[Black,20]}](*,Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}]]*);*)
(*PlotFinalPlane=If[DecayVolumeAsDetectorGivenExperiment=="False",Graphics3D[{Green,Opacity[0.2],FinalPlaneGivenExperiment}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.3],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2],EdgeForm[{Thick,Blue}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]];*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",*)
(*PlotDetector=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.2],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3],EdgeForm[{Thick,Red}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin,PlotFinalPlane,PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]];*)
(*Plot\[Theta]minmaxDecayVolume=Show[PlotOrigin,PlotDecayVolume,Graphics3D[{Thick,Black,Arrowheads[Large],Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]minDecayVolume}],Thick,Darker@Darker@Green,Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]maxDecayVolume}]},ViewPoint->Right]];*)
(*Plot\[Theta]minmaxDetector=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin,PlotDetector,Graphics3D[{Thick,Black,Arrowheads[Large],Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]minEndDetector}],Thick,Darker@Darker@Green,Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]maxEndDetector}]},ViewPoint->Right]]];*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",{PlotFullGeometry,Plot\[Theta]minmaxDecayVolume,Plot\[Theta]minmaxDetector},{PlotFullGeometry,Plot\[Theta]minmaxDecayVolume}]*)
(*]*)
(*expplots=ExperimentPlots;*)
(*expplots[[1]]*)
(*Print["Plots checking the correctness of evaluation of \!\(\*SubscriptBox[\(\[Theta]\), \(min\)]\), \!\(\*SubscriptBox[\(\[Theta]\), \(max\)]\) of detector and decay volume. The coordinates defining these angles are shown by arrows (black - \!\(\*SubscriptBox[\(\[Theta]\), \(min\)]\), green - \!\(\*SubscriptBox[\(\[Theta]\), \(max\)]\)):"]*)
(*expplots[[2]]*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",expplots[[3]]]*)


(* ::Input:: *)
(*BoxRatioz=5;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes->True,AxesLabel->{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin->{0,0,0},ViewProjection->"Orthographic",ViewCenter->{0,0,0},ViewPoint->{-0.7,0.25,-2},ViewVertical->{0,1,0},BoxRatios->{1,1,BoxRatioz},AxesStyle->{Thickness[0.03]},LabelStyle->{Directive[Black,20]}](*,Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}]]*);*)
(*PlotFinalPlane=If[DecayVolumeAsDetectorGivenExperiment=="False",Graphics3D[{Green,Opacity[0.2],FinalPlaneGivenExperiment}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment=="Annular cylinder",Show[Region[Style[finAnnular,White,Opacity[1](*,EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 1]]*)]],Region[Style[foutAnnular,Blue,Opacity[0.3](*,EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 0.1]]*)]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2](*,EdgeForm[{Thick,Blue}]*)],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]];*)
(*PlotDetector=If[DecayVolumeAsDetectorGivenExperiment=="False",If[GeometryGivenExperiment=="Annular cylinder"&&GivenExperiment!="LHCb-downstream-SciFi",Show[Region[Style[finDetAnnular,White,Opacity[1](*,EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 1]]*)]],Region[Style[foutDetAnnular,Red,Opacity[0.2](*,EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 0.1]]*)]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3](*,EdgeForm[{Thick,Red}]*)],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin(*,PlotFinalPlane*),PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]]*)


(* ::Input:: *)
(*BoxRatioz=3;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes->True,AxesLabel->{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin->{0,0,0},ViewProjection->"Orthographic",ViewCenter->{0,0,0},ViewPoint->{-0.7,0.25,-2},ViewVertical->{0,1,0},BoxRatios->{1,0.75,BoxRatioz},AxesStyle->{Thickness[0.03]},LabelStyle->{Directive[Black,20]}];*)
(*UT=Polygon[{{-1,-1,2.5},{-1,1,2.5},{1,1,2.5},{1,-1,2.5}}];*)
(*PlotUT=If[DecayVolumeAsDetectorGivenExperiment=="False",Graphics3D[{Green,Opacity[0.2],UT}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.3],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]];*)
(*PlotDetector=If[DecayVolumeAsDetectorGivenExperiment=="False",If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.2],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin,PlotUT,PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]]*)


(* ::Subsection:: *)
(*Adjustable plot*)


(* ::Input:: *)
(*BoxRatioz=10;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes->True,AxesLabel->{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin->{0,0,0},ViewProjection->"Orthographic",ViewCenter->{0,0,0},ViewPoint->{-0.7,0.25,-2},ViewVertical->{0,1,0},BoxRatios->{1,1.8,BoxRatioz},AxesStyle->{Thickness[0.03]},LabelStyle->{Directive[Black,20]}](*,Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}]]*);*)
(*PlotFinalPlane=If[DecayVolumeAsDetectorGivenExperiment=="False",Graphics3D[{Green,Opacity[0.2],FinalPlaneGivenExperiment}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.3],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2],EdgeForm[{Thick,Blue}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]];*)
(*PlotDetector=If[DecayVolumeAsDetectorGivenExperiment=="False",If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.2],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3],EdgeForm[{Thick,Red}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin,PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]];*)
(*PlotFullGeometry*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*Null*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*Null*)


(* ::Section:: *)
(*Defining \[Theta],E,z grid for the tabulation*)


(* ::Input:: *)
(*(*Grid of energies for which the decay products acceptance will be generated*)*)
(*ELLPvaluesFacility["FermilabBD"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[EmaxFacility["FermilabBD"]],(Log10[EmaxFacility["FermilabBD"]]-Log10[5.5])/50}]]//N;*)
(*ELLPvaluesFacility["ESS"]=Join[Table[e,{e,0.00501,0.14001,0.001}],{0.141,0.145,0.15,16,0.17,0.18,0.19,0.2,0.23,0.25,0.27,0.3,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.,1.1,1.3,1.5,2.,2.4}]//N;*)
(*ELLPvaluesFacility["Serpukhov"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[EmaxFacility["Serpukhov"]],(Log10[EmaxFacility["Serpukhov"]]-Log10[5.5])/40}]]//N;*)
(*ELLPvaluesFacility["SPS"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[EmaxFacility["SPS"]],(Log10[EmaxFacility["SPS"]]-Log10[5.5])/50}]]//N;*)
(*ELLPvaluesFacility["LHC"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[1000],(Log10[1000]-Log10[5.5])/50}],Table[10^ELLP,{ELLP,Log10[1100.],Log10[EmaxFacility["LHC"]],(Log10[EmaxFacility["LHC"]]-Log10[1100.])/30}]]//N;*)
(*ELLPvaluesFacility["FCC-hh"]=Join[{0.005,0.011,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[1000],(Log10[1000]-Log10[5.5])/30}],Table[10^ELLP,{ELLP,Log10[1100.],Log10[10000.],(Log10[10000.]-Log10[1100.])/30}],Table[10^ELLP,{ELLP,Log10[11000.],Log10[EmaxFacility["FCC-hh"]],(Log10[EmaxFacility["FCC-hh"]]-Log10[11000.])/30}]]//N;*)
(**)
(*ELLPvaluesFacility["LHC-fixed-target"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[1000],(Log10[1000]-Log10[5.5])/50}],Table[10^ELLP,{ELLP,Log10[1100.],Log10[EmaxFacility["LHC-fixed-target"]],(Log10[EmaxFacility["LHC-fixed-target"]]-Log10[1100.])/30}]]//N;*)
(**)
(*(*hacking this value temporarily for SHIFT*)*)
(*ThetaDecVolGivenExperimentMin = 0.005882420789*)
(**)
(*(*Grid of Subscript[\[Theta], LLP],Subscript[z, LLP]*)*)
(*\[Theta]LLPrange=\[Theta]grid[DecayVolumeAsDetectorGivenExperiment,ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax,ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax];*)
(**)
(*(*Define the step size function based on experiment name and z value*)*)
(*\[CapitalDelta]zVal[\[CapitalDelta]z_,z_,experimentName_]:=If[StringContainsQ[experimentName,"SHIFT"],*)
(*(*for SHIFT*)*)
(*Piecewise[Table[{10^-n,z<10^-(n-1)},{n,15,0,-1}]~Join~{{10^1,True}}],*)
(*(*for other experiments*)*)
(*Min[\[CapitalDelta]z/10,Max[0.5,\[CapitalDelta]z/45.]]*)
(*];*)
(*(*Way to define a denser grid*)*)
(*(*\[CapitalDelta]zVal[\[CapitalDelta]z_,z_,experimentName_]:=Module[{verydenserDelta,denserDelta, linearDelta},*)
(*verydenserDelta= z/5;*)
(*denserDelta=z;*)
(*linearDelta=Min[\[CapitalDelta]z/10,Max[0.5,\[CapitalDelta]z/45.]];*)
(*(*Conditional based on the experiment name*)If[StringContainsQ[experimentName,"SHIFT"],Piecewise[{{verydenserDelta,z<0.1},{denserDelta,z<5&&z>=0.1},{linearDelta,z>=5}}],linearDelta]]*)*)
(*zLLP=zToDecayVolumeGivenExperiment;*)
(*zLLPrangeTemp={};*)
(**)
(*While[zLLP<=zMaxDecayVolumeGivenExperiment,AppendTo[zLLPrangeTemp,zLLP];*)
(*zLLP+=\[CapitalDelta]zVal[zMaxDecayVolumeGivenExperiment-zToDecayVolumeGivenExperiment,zLLP, GivenExperiment];];*)
(**)
(*zLLPrangeTemp=N[zLLPrangeTemp];*)
(**)
(*zLLPrange=zLLPrangeTemp;*)
(*(*Add zToDecayVolumeGivenExperiment as first value if it is not included*)*)
(*If[zLLPrangeTemp[[1]]!=zToDecayVolumeGivenExperiment,zLLPrange=Prepend[zLLPrangeTemp,zToDecayVolumeGivenExperiment];];*)
(*(*Add zMaxDecayVolumeGivenExperiment as first value if it is not included*)*)
(*If[zLLPrangeTemp[[-1]]!=zMaxDecayVolumeGivenExperiment,zLLPrange=Append[zLLPrange,zMaxDecayVolumeGivenExperiment];];*)
(**)
(*TableLLPgrid\[Theta]z=Flatten[Table[{\[Theta]LLP,zLLP},{\[Theta]LLP,\[Theta]LLPrange},{zLLP,zLLPrange}],{1,2}];*)
(*(*List of Subscript[E, LLP]*)*)
(*ELLPvalues=ELLPvaluesFacility[FacilityGivenExperiment];*)


(* ::Section:: *)
(*Azimuthal acceptance calculations*)


(* ::Input:: *)
(*NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/azimuthal-acceptance.nb"}]];*)
(*TableAzimuthalAcceptancesToDet=Table[Block\[Theta]zLLP\[Epsilon]Az\[Phi][EpsilonAzPhiListToDet,j],{j,1,Length[TableLLPgrid\[Theta]z],1}];//AbsoluteTiming*)
(*TableAzimuthalAcceptancesNotToDet=If[DecayVolumeAsDetectorGivenExperiment=="False",Table[Block\[Theta]zLLP\[Epsilon]Az\[Phi][EpsilonAzPhiListNotToDet,j],{j,1,Length[TableLLPgrid\[Theta]z],1}]];//AbsoluteTiming*)
(*TableLLPgridWithELLPtemp[dat_]:=Flatten[Table[{dat[[i]][[1]],ELLPvalues[[k]],dat[[i]][[2]],dat[[i]][[3]],dat[[i]][[4]][[j]]},{i,1,Length[dat],1},{k,1,Length[ELLPvalues],1},{j,1,NofPhiVals,1}],{1,2,3}];//AbsoluteTiming*)
(*(*Grid Subscript[E, LLP], Subscript[\[Theta], LLP], Subscript[x, long,LLP],Subscript[\[Epsilon], azimuthal,LLP],Subscript[\[Phi], LLP] within the decay volume, assuming that LLP points to the end of detector, or not points to the end of detector*)*)
(*gridLLPtoDet=TableLLPgridWithELLPtemp[TableAzimuthalAcceptancesToDet];//AbsoluteTiming*)
(*gridLLPnotToDet=If[DecayVolumeAsDetectorGivenExperiment=="False",TableLLPgridWithELLPtemp[TableAzimuthalAcceptancesNotToDet],gridLLPtoDet];//AbsoluteTiming*)
(*(*The same but without the column Subscript[\[Phi], LLP]*)*)
(*{gridReducedLLPtoDet,gridReducedLLPnotToDet}={DeleteDuplicatesBy[gridLLPtoDet,{#[[1]],#[[2]],#[[3]],#[[4]]}&][[All,{1,2,3,4}]],If[DecayVolumeAsDetectorGivenExperiment=="False",DeleteDuplicatesBy[gridLLPnotToDet,{#[[1]],#[[2]],#[[3]],#[[4]]}&][[All,{1,2,3,4}]]]};*)
(*(*Meaning of columns in the tables gridLLPtoDet,gridLLPnotToDet*)*)
(*index\[Theta]LLP=1;*)
(*indexELLP=2;*)
(*indexzLLP=3;*)
(*indexLLPazAcc=4;*)
(*index\[Phi]LLP=5;*)
(*Print["\[Theta] grid:"]*)
(*thgrid=DeleteDuplicates[gridLLPtoDet[[All,1]]]*)
(*Print["E grid:"]*)
(*egrid=DeleteDuplicates[gridLLPtoDet[[All,2]]]*)
(*Print["z grid:"]*)
(*zgrid=DeleteDuplicates[gridLLPtoDet[[All,3]]]*)
(*azaccdata=Join[gridReducedLLPtoDet[[All,{1,3}]],If[DecayVolumeAsDetectorGivenExperiment=="False",gridReducedLLPtoDet[[All,{4}]]+gridReducedLLPnotToDet[[All,{4}]],gridReducedLLPtoDet[[All,{4}]]],2];*)
(*Print["The volume of the decay volume (in \!\(\*SuperscriptBox[\(m\), \(3\)]\)) calculated by the azimuthal acceptance (compare with the true volume obtained using simple formulas):"]*)
(*azacc[th_,z_]=Interpolation[DeleteDuplicatesBy[azaccdata,{#[[1]],#[[2]]}&],InterpolationOrder->1][th,z];*)
(*{{"Meaning","Volume - computed as \[Integral]2\!\(\*SubscriptBox[\(\[Pi]\[Epsilon]\), \(az\)]\)(\[Theta],z)sin(\[Theta]) \!\(\*SuperscriptBox[\(r\), \(2\)]\)(z)d\[Theta]dr", "Volume - computed internally as Volume[Decay Volume]", "Volume - computed as \[Integral]IfLLPinsideDecVol dx dy dz"},{"Comment","","Must match the 2nd column with O(few %) precision","Must match the 2nd column with O(few %) precision"},{"Value",NIntegrate[2*Pi*azacc[th,z]*Sin[th] z^2/Cos[th]^3,{th,thgrid[[1]],thgrid[[-1]]},{z,zgrid[[1]],zgrid[[-1]]}, WorkingPrecision-> 16],Volume[DecayVolumeGeometryGivenExperiment],VolumeFromIf[GivenExperiment]}}//TableForm*)


(* ::Subsubsection:: *)
(*Visualization of the generated acceptance points*)
(**)


(* ::Input:: *)
(**)
(*(*_______________________________________________________*)*)
(*(*Visualization of the generated LLP decay points. Uncomment if needed*)*)
(*(*_______________________________________________________*)*)
(*AzimuthalAcceptanceVisualizationChoice="Yes";*)
(*(*AzimuthalAcceptanceVisualizationChoice=dropdownDialog[{"Yes","No"},"Do you want to visualize the generated grid of the LLP decay points inside the decay volume?"];*)*)
(*If[AzimuthalAcceptanceVisualizationChoice=="Yes",Print["Green points - the decay points of the LLPs pointing to the end of the detector. Cyan points - for the LLPs that do not point to the detector (less dense grid)"]]*)
(*If[AzimuthalAcceptanceVisualizationChoice=="Yes",*)
(*anglestocart=Compile[{{tab,_Real,2}},{#[[3]]/Cos[#[[1]]] Sin[#[[1]]]Cos[#[[5]]],#[[3]]/Cos[#[[1]]] Sin[#[[1]]]Sin[#[[5]]],#[[3]]}&/@tab,CompilationTarget->"C",RuntimeOptions->"Speed"];*)
(*pointstodet=anglestocart[Select[gridLLPtoDet,#[[4]]!=0&]];*)
(*pointsnottodet=If[Length[gridLLPnotToDet]!=0,anglestocart[Select[gridLLPnotToDet,#[[4]]!=0&]]];*)
(*(*The commented code explicitly checks whether the generate point ivall belongs to the decay volume. The result must always be "True"*)*)
(*(*ivall=3;*)
(*RegionMember[DecayVolumeGeometryGivenExperiment,pointstodet[[3]]]*)*)
(*PlotDetector1=If[DecayVolumeAsDetectorGivenExperiment=="False",If[GeometryGivenExperiment=="Annular cylinder"&&StringContainsQ[GivenExperiment,"LHCb-downstream-SciFi"]==True,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.1],EdgeForm[{Thick,Red}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotDecayVolume1=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.1],EdgeForm[{Thick,Blue}]],BoxRatios->{1,0.2,1},Boxed->True,Axes->True]];*)
(*fig=Show[PlotOrigin,PlotDecayVolume1,PlotDetector,ListPointPlot3D[{pointstodet},PlotStyle->{{PointSize[0.005],Darker@Green},{PointSize[0.02],Darker@Green},{Black}},BoxRatios->{1,1,1},Boxed->True,Axes->True],ListPointPlot3D[{pointsnottodet},PlotStyle->{{PointSize[0.005],Cyan},{PointSize[0.03],Darker@Red},{PointSize[0.02],Darker@Green},{Black}}]]*)
(*(*Export[FileNameJoin[{NotebookDirectory[],"temp1/mathusla-points.pdf"}],fig]*)]*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*Null*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*Null*)


(* ::Title::Closed:: *)
(*Computing the decay products acceptance*)


(* ::Chapter::Closed:: *)
(*Definitions*)


(* ::Section:: *)
(*Initializing all routines*)


(* ::Input:: *)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/decay-acceptance.nb"}]]];*)


(* ::Section:: *)
(*Mass range for the acceptance computation*)


(* ::Input:: *)
(*(*Mass range for scalars. If the facility is not FCC-hh/LHC (where scalars heavier than B may be produced), then the mass range is bounded by Subscript[m, B] - Subscript[m, \[Pi]]. Otherwise, it is up to Subscript[m, h]/2*)*)
(*mLLPlistTemp["Scalar"]=Join[{0.02,0.05,0.1,0.2,0.22,0.3,0.4,0.5,0.7,0.9,1.05,1.3,1.6,1.99},mjetsrange["Scalar"]];*)
(*mLLPlist["Scalar"]=If[MemberQ[{"LHC","FCC-hh", "LHC-fixed-target"},FacilityGivenExperiment]==False,Select[mLLPlistTemp["Scalar"],#<=5.1&],mLLPlistTemp["Scalar"]];*)
(*(*For HNLs - similarly*)*)
(*Do[*)
(*mLLPlistTemp[LLP]=Join[Select[{0.02,0.05,0.1,0.17,0.35,0.5,0.75,1.,1.19,1.5},#<Min[mjetsrange[LLP]]&],mjetsrange[LLP],{1.75}]//Sort//DeleteDuplicates;*)
(*mLLPlist[LLP]=If[MemberQ[{"LHC","FCC-hh", "LHC-fixed-target"},FacilityGivenExperiment]==False,Select[mLLPlistTemp[LLP],#<=5.3&],mLLPlistTemp[LLP]];*)
(*,{LLP,{"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau"}}]*)
(*(*ALPs coupled to gluons*)*)
(*mLLPlistTemp["ALP-gluon"]=Join[Select[{0.02,0.05,0.1,0.25,0.3,0.5,0.75,1.,1.25,1.5,1.8,2.3},#<Min[mjetsrange["ALP-gluon"]]&],mjetsrange["ALP-gluon"]];*)
(*mLLPlist["ALP-gluon"]=If[ECALoptionGivenExperiment=="False",Select[mLLPlistTemp["ALP-gluon"],#>0.14*2&],mLLPlistTemp["ALP-gluon"]];*)
(*(*ALPs coupled to fermions*)*)
(*mLLPlist["ALP-fermion"]=Join[Select[{0.02,0.05,0.1,0.22,0.3,0.5,0.6,0.7,0.8,0.9,1.1,1.5,1.8,2.3},#<Min[mjetsrange["ALP-fermion"]]&],mjetsrange["ALP-fermion"]];*)
(*(*ALPs coupled to photons*)*)
(*mLLPlist["ALP-photon"]={0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.25,0.5,0.75,1.,1.25,1.5,1.75,2.25,2.75,3.,3.5,4.,4.5}//N//Sort;*)
(*mLLPlist["DP"]=Join[Select[{0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.2,0.22,0.35,0.5,0.75,1.,1.25,1.75,2.25},#<Min[mjetsrange["DP"]]&],mjetsrange["DP"]];*)
(*mLLPlist["B-L"]=mLLPlist["B-3Le-Lmu+Ltau"]=mLLPlist["B-Le-3Lmu+Ltau"]=Join[Select[{0.02,0.03,0.04,0.05,0.06,0.07,0.1,0.2,0.22,0.35,0.5,0.75,1.,1.25,1.75,2.25},#<Min[mjetsrange["B-L"]]&],mjetsrange["B-L"]];*)
(*mLLPlist["B-3Lmu"]=Join[{0.215,0.25},Select[mLLPlist["B-L"],#>0.22&]];*)
(*If[FacilityGivenExperiment=="ESS",*)
(*Do[mLLPlist[LLP]=Join[Select[mLLPlist[LLP],#<2.&],{0.01,0.02,0.03,0.04,0.06,0.07,0.08,0.09,0.1,0.105,0.11,0.115,0.12,0.125,0.13,0.135,0.15,0.18,0.2,0.22,0.3,0.35,0.4,0.45,0.55}]//DeleteDuplicates//Sort,{LLP,{"ALP-gluon","ALP-fermion","ALP-photon","DP","B-L","Scalar"}}];*)
(*Do[mLLPlist[LLP]={0.005,0.01,0.015,0.02,0.025,0.03,0.035,0.04,0.045,0.05,0.055,0.06,0.065,0.07,0.075,0.08,0.085,0.09,0.095,0.1,0.103,0.105,0.11,0.115,0.12,0.125,0.13,0.135,0.14},{LLP,{"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau"}}];*)
(*]*)


(* ::Section:: *)
(*Final block*)


(* ::Input:: *)
(*phr0="Use old phenomenology from 1901.09966, or the new one from 2310.03524?";*)
(*a0={"New","Old"};*)
(*phr1[LLP_]:=Row[{"Default decay chanels: ",ProcessesListRefined[LLP,ECALoptionGivenExperiment],". Keep them?"}];*)
(*a1={"Yes","No"};*)
(*phr2="How many decay products that in principle may be detected must pass all the criteria?";*)
(*a2={">=2",">=n","All detectable"};*)
(*phr3="Heavy LLPs decay into partons. Would you like to use the phase space of hadronized decay products of the LLPs, or use partons instead?";*)
(*a3={"Hadronized products","Partons"};*)
(*FinalBlock[LLP_,isim_]:=Block[{},*)
(*masslist=mLLPlist[LLP];*)
(*(*If[LLP=="ALP-fermion",*)
(*alpfermionselection=dropdownDialog[{"New","Old"},Row[{"Use old phenomenology from 1901.09966, or the new one from 2310.03524?"}]];*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"],*)
(*LLPchoiceForComputation=LLP;*)
(*];*)*)
(*If[LLP=="ALP-fermion",*)
(*{alpfermionselection}=choicesDialog[Style[LLP,Bold],{{phr0,a0}}];*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"];*)
(*If[GivenExperiment!="CHARM-photon",*)
(*{decaychannelschoice,acceptancetypechoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr2,a2},{phr3,a3}}],{decaychannelschoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr3,a3}}]];*)
(*,*)
(*LLPchoiceForComputation=LLP;*)
(*If[GivenExperiment!="CHARM-photon",*)
(*{decaychannelschoice,acceptancetypechoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr2,a2},{phr3,a3}}],*)
(*{decaychannelschoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr3,a3}}]];*)
(*];*)
(*hadropt=If[HadronizationOptionChoice=="Hadronized products","True","False"];*)
(*If[acceptancetypechoice==">=n",DynamicModule[{input1=2,list,phrase},*)
(*DialogInput[Column[{TextCell["Enter the minimal number of detectable tracks:"],InputField[Dynamic[input1],Expression],Button["Submit",DialogReturn[{ntracksmin}={input1}],ImageSize->Automatic]}]]];];*)
(*(*decaychannelschoice=dropdownDialog[{"Yes","No"},Row[{"Default decay chanels: ",ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],". Keep them?"}]];*)*)
(*(*List of decay processes considered as visible for the given calculation*)*)
(*proclist=If[decaychannelschoice=="No", selectionDialog[ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],"Select decay channels:"],ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment]];*)
(*(*The total branching ratio of the selected visible channels*)*)
(*BrVisibleExport[mLLP_]=BrVisibleGivenSetup[LLPchoiceForComputation,mLLP,proclist,ECALoptionGivenExperiment];*)
(*(*Redefining the mass list such that it matches the domain where the br ratio of selected channels is non-zero*)*)
(*tabbrvis=Table[{mLLP,BrVisibleExport[mLLP]},{mLLP,masslist[[1]],masslist[[-1]],(masslist[[-1]]-masslist[[1]])/100}];*)
(*{mminnonzero,mmaxnonzero}=Select[tabbrvis,#[[2]]>10^-15.&][[All,1]]//MinMax;*)
(*masslist=Join[{mminnonzero},Select[masslist,mminnonzero<#<mmaxnonzero&],{mmaxnonzero}]//N;*)
(*(*Calculation of the decay products acceptance for the selected visible channels*)*)
(*If[Length[proclist]*Length[masslist]!=0,*)
(*(*tabcomp=Monitor[Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice],{l,1,Length[masslist],1}],Row[{ProgressIndicator[l,{1,Length[masslist]}],"i = ",l,"/",Length[masslist]," (Subscript[m, LLP] = ",masslist[[l]]," GeV)"}," "]];*)*)
(*tabcomp=ResourceFunction["MonitorProgress"]@Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice,ntracksmin],{l,1,Length[masslist],1}];*)
(*GivenExperimentNameFin=If[hadropt=="True",GivenExperimentName,GivenExperimentName<>"-no-hadronization"];*)
(*filenameexport=ToString@StringForm["Acceptance_``_for_``.m",Sequence@@{GivenExperimentNameFin,LLP}];*)
(*Flatten[tabcomp,1],*)
(*Print["No processes for the given LLP/ECAL availability!"]]*)
(*]*)
(*BlockExport[LLP_,isim_]:=Block[{},*)
(*datatemp=FinalBlock[LLP,isim];*)
(*Export[FileNameJoin[{NotebookDirectory[],"Acceptances",GivenExperimentNameFin,filenameexport}],{FacilityGivenExperiment,ECALoptionGivenExperiment,datatemp,TableParticlesNumbersGivenExperiment,BrVisibleExport[mLLP]},"MX"]*)
(*]*)


(* ::Subsection::Closed:: *)
(*Silent run*)


(* ::Input:: *)
(*SilentOption=0;*)
(*If[SilentOption!=0,*)
(*alpfermionselection="New";*)
(*acceptancetypechoice=">=n";*)
(*decaychannelschoice="Yes";*)
(*HadronizationOptionChoice="Hadronized products";*)
(*ntracksmin=4;*)
(*FinalBlock[LLP_,isim_]:=Block[{},*)
(*masslist=mLLPlist[LLP];*)
(*(*If[LLP=="ALP-fermion",*)
(*alpfermionselection=dropdownDialog[{"New","Old"},Row[{"Use old phenomenology from 1901.09966, or the new one from 2310.03524?"}]];*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"],*)
(*LLPchoiceForComputation=LLP;*)
(*];*)*)
(*If[LLP=="ALP-fermion",*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"];*)
(*,*)
(*LLPchoiceForComputation=LLP;*)
(*];*)
(*hadropt=If[HadronizationOptionChoice=="Hadronized products","True","False"];*)
(*(*decaychannelschoice=dropdownDialog[{"Yes","No"},Row[{"Default decay chanels: ",ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],". Keep them?"}]];*)*)
(*(*List of decay processes considered as visible for the given calculation*)*)
(*proclist=If[decaychannelschoice=="No", selectionDialog[ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],"Select decay channels:"],ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment]];*)
(*(*The total branching ratio of the selected visible channels*)*)
(*BrVisibleExport[mLLP_]=BrVisibleGivenSetup[LLPchoiceForComputation,mLLP,proclist,ECALoptionGivenExperiment];*)
(*(*Redefining the mass list such that it matches the domain where the br ratio of selected channels is non-zero*)*)
(*tabbrvis=Table[{mLLP,BrVisibleExport[mLLP]},{mLLP,masslist[[1]],masslist[[-1]],(masslist[[-1]]-masslist[[1]])/100}];*)
(*{mminnonzero,mmaxnonzero}=Select[tabbrvis,#[[2]]>10^-15.&][[All,1]]//MinMax;*)
(*masslist=Join[{mminnonzero},Select[masslist,mminnonzero<#<mmaxnonzero&],{mmaxnonzero}]//N;*)
(*(*Calculation of the decay products acceptance for the selected visible channels*)*)
(*If[Length[proclist]*Length[masslist]!=0,*)
(*(*tabcomp=Monitor[Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice],{l,1,Length[masslist],1}],Row[{ProgressIndicator[l,{1,Length[masslist]}],"i = ",l,"/",Length[masslist]," (Subscript[m, LLP] = ",masslist[[l]]," GeV)"}," "]];*)*)
(*tabcomp=ResourceFunction["MonitorProgress"]@Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice,ntracksmin],{l,1,Length[masslist],1}];*)
(*GivenExperimentNameFin=If[hadropt=="True",GivenExperimentName,GivenExperimentName<>"-no-hadronization"];*)
(*filenameexport=ToString@StringForm["Acceptance_``_for_``.m",Sequence@@{GivenExperimentNameFin,LLP}];*)
(*Flatten[tabcomp,1],*)
(*Print["No processes for the given LLP/ECAL availability!"]]*)
(*];*)
(*BlockExport[LLP_,isim_]:=Block[{},*)
(*datatemp=FinalBlock[LLP,isim];*)
(*Export[FileNameJoin[{NotebookDirectory[],"Acceptances",GivenExperimentNameFin,filenameexport}],{FacilityGivenExperiment,ECALoptionGivenExperiment,datatemp,TableParticlesNumbersGivenExperiment,BrVisibleExport[mLLP]},"MX"]*)
(*]*)
(*]*)


(* ::Chapter::Closed:: *)
(*Actual computation of the decay acceptance*)


(* ::Input:: *)
(*BlockAcceptanceComputation[LLP_]:=Module[{},*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,LLP,All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*]*)
(*Print["List of LLPs:"]*)
(*LLPlistReduced=Join[Select[LLPlist,!MemberQ[{"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau","ALP-fermion-no-hadronic-decays"},#]&],{"HNL"}]//Sort*)
(*selectionDialog[list_,phrase_]:=DialogInput[{choice={}},Column[{Row[{phrase}],TogglerBar[Dynamic[choice],list,Appearance->"Vertical"],Button["OK",DialogReturn[choice]]}]]*)
(*Print["List of LLPs for which the acceptance will be computed:"]*)
(*SelectedLLPlistTemp=selectionDialog[Join[LLPlistReduced]//Sort,"Select LLPs for which acceptances will be computed:"]*)
(*SelectedLLPlist=Join[SelectedLLPlistTemp,{"Technical"}];*)
(*GivenExperimentName=DialogInput[{cut=GivenExperiment},Column[{"Enter the name of the experiment for exporting:",InputField[Dynamic[cut],String],Button["Proceed",DialogReturn[cut],ImageSize->Automatic]}]];*)
(*If[(DirectoryQ["Acceptances"]//ToString)=="False",CreateDirectory["Acceptances"]];*)
(*If[(DirectoryQ[FileNameJoin[{"Acceptances",GivenExperimentName}]]//ToString)=="False",CreateDirectory[FileNameJoin[{"Acceptances",GivenExperimentName}]]];*)
(*(*ChoiceDialog["Choose the LLP for which acceptances will be computed:",Join[LLPlistReduced,{"All"}],Appearance\[Rule]"Vertical"\[Rule]{Automatic,3}]*)*)
(*ivaltest=If[GivenExperiment=="SHiNESS",10^4, If[StringContainsQ[GivenExperiment,"SHIFT"],100, 100]];*)
(*Do[BlockAcceptanceComputation[SelectedLLPlist[[i]]],{i,1,Length[SelectedLLPlist],1}]*)


(* ::Title::Closed:: *)
(*Chapter to be automatically launched by the previous chapter. No need to launch it manually*)


(* ::Chapter::Closed:: *)
(*Scalar*)


(* ::Input:: *)
(*dataS=BlockExport["Scalar",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*HNL*)


(* ::Section::Closed:: *)
(*e mixing*)


(* ::Input:: *)
(*dataS=BlockExport["HNL-mixing-e",ivaltest];//AbsoluteTiming*)


(* ::Section::Closed:: *)
(*\[Mu] mixing*)


(* ::Input:: *)
(*dataS=BlockExport["HNL-mixing-mu",10^3];//AbsoluteTiming*)


(* ::Section::Closed:: *)
(*\[Tau] mixing*)


(* ::Input:: *)
(*dataS=BlockExport["HNL-mixing-tau",10^3];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*Dark photon*)


(* ::Input:: *)
(*dataS=BlockExport["DP",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*ALP-fermion*)


(* ::Input:: *)
(*dataS=BlockExport["ALP-fermion",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*ALP-gluon*)


(* ::Input:: *)
(*dataS=BlockExport["ALP-gluon",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*ALP-photon*)


(* ::Input:: *)
(*dataS=BlockExport["ALP-photon",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*B-L mediator*)


(* ::Input:: *)
(*dataS=BlockExport["B-L",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*B-3Subscript[L, \[Mu]] mediator*)


(* ::Input:: *)
(*dataS=BlockExport["B-3Lmu",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*B-3Subscript[L, e]-Subscript[L, \[Mu]]+Subscript[L, \[Tau]] mediator*)


(* ::Input:: *)
(*dataS=BlockExport["B-3Le-Lmu+Ltau",ivaltest];//AbsoluteTiming*)


(* ::Chapter::Closed:: *)
(*B-Subscript[L, e]-3Subscript[L, \[Mu]]+Subscript[L, \[Tau]] mediator*)


(* ::Input:: *)
(*dataS=BlockExport["B-Le-3Lmu+Ltau",ivaltest];//AbsoluteTiming*)


(* ::Title::Closed:: *)
(*Deleting generated cells/proceeding to an other experiment*)


(* ::Input:: *)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*relaunch=dropdownDialog[{"Yes","No"},Row[{"Would you like to re-launch the calculation for another experiment after the given computation?"}]]*)
(*If[relaunch=="Yes",*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,"Re-evaluation",All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*]*)
(*If[relaunch=="No",*)
(*deletecellsopt=dropdownDialog[{"Yes","No"},Row[{"Would you like to remove all the generated output cells after the given computation?"}]];*)
(*If[deletecellsopt=="Yes",FrontEndTokenExecute["DeleteGeneratedCells"];*)
(*FrontEndTokenExecute["SelectAll"];*)
(*FrontEndTokenExecute["SelectionCloseAllGroups"];];*)
(*]*)


(* ::Input:: *)
(*x*)


(* ::Input:: *)
(*2*)


(* ::Title::Closed:: *)
(*Some tests*)


(* ::Section::Closed:: *)
(*Some tests*)


(* ::Subsection::Closed:: *)
(*SHiNESS*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


(* ::Input:: *)
(*ENdistrFrom\[Mu][mN_,EN_]=(1/(1.*EN - 4.761904761904762*mN^2 - 0.05249999999999999)^3)**)
(*  (Sqrt[(EN^2 - mN^2)*(0.04409999999999999*EN^2 + EN*(-(0.42*mN^2) - 0.004630394999999999) + mN^4 + 0.022049499999999996*mN^2 + 0.00012154511256249997)]**)
(*   (2.2399999999999998*EN^4 + EN^3*(-(37.33333333333331*mN^2) - 0.4115986666666664) + EN^2*(203.17460317460308*mN^4 + 5.599993650793649*mN^2 + 0.024695929998412688) + *)
(*    EN*(-(362.8117913832198*mN^6) - 22.666666666666657*mN^4 - 0.24990133331065745*mN^2 - 0.00048620249974999755) + 25.396825396825378*mN^6 + 0.5600063492063486*mN^4 + 0.0030870699968253965*mN^2 - *)
(*    3.825065264528859*^-20));*)
(*ENmaxFrom\[Mu][mN_]=(0.105^2+mN^2-(0.5*10^-3)^2)/(0.105*2);*)
(*energysampling=Hold@Compile[{{mN,_Real},{nevents,_Integer}},Module[{enrand,weights},*)
(*enrand=RandomReal[{mN,ENmaxFrom\[Mu][mN]},Max[10^6,nevents]];*)
(*weights=ENdistrFrom\[Mu][mN,enrand];*)
(*RandomChoice[weights->enrand,nevents]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{ENdistrFrom\[Mu],ENmaxFrom\[Mu]}]//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@energysampling;*)
(*EnergySampling[prod_,mN_,Nevents_]:=If[prod=="\[Mu]",energysampling[mN,Nevents],If[prod=="Fake \[Mu]",ConstantArray[(0.105^2+mN^2)/(2*0.105),Nevents],ConstantArray[(0.135^2+mN^2-0.105^2)/(2*0.135),Nevents]]]*)
(*boosting=Hold@Compile[{{energies,_Real},{momenta,_Real,1},{phasespace,_Real,1},{mass,_Real}},Module[{pxm,pym,pzm,pxd1,pyd1,pzd1,ed1,pxd2,pyd2,pzd2,ed2,px1lab,py1lab,pz1lab,e1lab,px2lab,py2lab,pz2lab,e2lab,mass1,mass2},*)
(*pxm=Compile`GetElement[momenta,1];*)
(*pym=Compile`GetElement[momenta,2];*)
(*pzm=Compile`GetElement[momenta,3];*)
(*pxd1=Compile`GetElement[phasespace,indexpx1];*)
(*pyd1=Compile`GetElement[phasespace,indexpy1];*)
(*pzd1=Compile`GetElement[phasespace,indexpz1];*)
(*ed1=Compile`GetElement[phasespace,indexE1];*)
(*mass1=Compile`GetElement[phasespace,indexm1];*)
(*pxd2=Compile`GetElement[phasespace,LengthDataProduct+indexpx1];*)
(*pyd2=Compile`GetElement[phasespace,LengthDataProduct+indexpy1];*)
(*pzd2=Compile`GetElement[phasespace,LengthDataProduct+indexpz1];*)
(*ed2=Compile`GetElement[phasespace,LengthDataProduct+indexE1];*)
(*mass2=Compile`GetElement[phasespace,LengthDataProduct+indexm1];*)
(*px1lab=pproductLab1Cart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*py1lab=pproductLab2Cart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*pz1lab=pproductLab3Cart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*e1lab=EproductLabCart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*px2lab=pproductLab1Cart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*py2lab=pproductLab2Cart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*pz2lab=pproductLab3Cart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*e2lab=EproductLabCart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*{px1lab,py1lab,pz1lab,e1lab,mass1,px2lab,py2lab,pz2lab,e2lab,mass2}*)
(*],CompilationTarget->"C",RuntimeAttributes->{Listable},RuntimeOptions->"Speed",Parallelization->True]/.ruleDown[{pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{LengthDataProduct,indexpx1,indexpy1,indexpz1,indexE1,indexm1}]//ReleaseHold;*)
(*\[Alpha]Smearing=Hold@Compile[{{daughtermomenta,_Real,1}},Module[{energy1,energy2,mass1,mass2,px1,px2,py1,py2,pz1,pz2,\[Theta]1,\[Theta]2,\[Phi]1,\[Phi]2,\[Theta]smeared1,\[Theta]smeared2,\[Alpha]Kelly,\[Alpha]My,u1,u2,z1,z2,\[Alpha]Unsmeared},*)
(*energy1=Compile`GetElement[daughtermomenta,indexE1];*)
(*energy2=Compile`GetElement[daughtermomenta,indexm1+indexE1];*)
(*mass1=Compile`GetElement[daughtermomenta,indexm1];*)
(*mass2=Compile`GetElement[daughtermomenta,indexm1+indexm1];*)
(*px1=Compile`GetElement[daughtermomenta,indexpx1];*)
(*py1=Compile`GetElement[daughtermomenta,indexpy1];*)
(*pz1=Compile`GetElement[daughtermomenta,indexpz1];*)
(*px2=Compile`GetElement[daughtermomenta,indexm1+indexpx1];*)
(*py2=Compile`GetElement[daughtermomenta,indexm1+indexpy1];*)
(*pz2=Compile`GetElement[daughtermomenta,indexm1+indexpz1];*)
(*\[Theta]1=\[Theta]Val[px1,py1,pz1];*)
(*\[Theta]2=\[Theta]Val[px2,py2,pz2];*)
(*\[Phi]1=\[Phi]Val[px1,py1];*)
(*\[Phi]2=\[Phi]Val[px1,py1];*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z1=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z2=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*\[Theta]smeared1=\[Theta]1+Pi/180.*10*z1;*)
(*\[Theta]smeared2=\[Theta]2+Pi/180.*10*z2;*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z2=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*\[Alpha]Kelly=ArcCos[Cos[\[Phi]2-\[Phi]1]Sin[\[Theta]smeared1]Sin[\[Theta]smeared2]+Cos[\[Theta]smeared1]*Cos[\[Theta]smeared2]];*)
(*(*\[Alpha]Kelly=ArcCos[Cos[\[Phi]2-\[Phi]1+Pi/180.*10*z2]Sin[\[Theta]smeared1]Sin[\[Theta]smeared2]+Cos[\[Theta]smeared1]*Cos[\[Theta]smeared2]];*)*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z2=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*\[Alpha]Unsmeared=ArcCos[Cos[\[Phi]2-\[Phi]1]Sin[\[Theta]1]Sin[\[Theta]2]+Cos[\[Theta]1]*Cos[\[Theta]2]];*)
(*\[Alpha]My=(*Min[Pi,Max[0.,\[Alpha]Unsmeared+Pi/180.*10*z2]]*)ArcCos[Cos[\[Alpha]Unsmeared+Pi/180.*10*z2]];*)
(*{\[Alpha]Unsmeared,\[Alpha]My,\[Alpha]Kelly}*)
(*],CompilationTarget->"C",RuntimeAttributes->{Listable},RuntimeOptions->"Speed",Parallelization->True]/.ruleDown[{\[Theta]Val,\[Phi]Val}]/.ruleOwn[{indexm1,indexE1,indexpx1,indexpy1,indexpz1}]//ReleaseHold;*)
(*selection=Hold@Compile[{{finaldata,_Real,2},{Ecut,_Real},{\[Theta]cut,_Real},{index,_Integer}},Module[{datasel,len},*)
(*datasel=Select[finaldata,#[[indexE1]]>Ecut&&#[[indexE1+indexm1]]>Ecut&&#[[-index]]>\[Theta]cut&];*)
(*Total[datasel[[All,-4]]]/Total[finaldata[[All,-4]]]*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{indexE1,indexm1}]//ReleaseHold*)
(*(*\[Theta]\[Phi]Vals=Select[gridLLPtoDet//N//Developer`ToPackedArray,#[[4]]!=0.&][[All,{1,-1}]];*)*)
(*(*\[Theta]\[Phi]Vals={ArcCos[RandomReal[{-1,1},5*10^5]],RandomReal[{-Pi,Pi},5*10^5]}//Transpose;*)*)
(*pts=RandomPoint[DecayVolumeGeometryGivenExperiment,3*10^5];//AbsoluteTiming*)
(*\[Theta]\[Phi]ValsRand=Hold@Compile[{{ptscyl,_Real,1}},Module[{},*)
(*{\[Theta]Val[Compile`GetElement[ptscyl,1],Compile`GetElement[ptscyl,2],Compile`GetElement[ptscyl,3]],\[Phi]Val[Compile`GetElement[ptscyl,1],Compile`GetElement[ptscyl,2]]}*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{\[Theta]Val,\[Phi]Val}]//ReleaseHold*)
(*\[Theta]\[Phi]Vals=\[Theta]\[Phi]ValsRand[pts];//AbsoluteTiming*)


(* ::Subsubsection::Closed:: *)
(*Phase space: HNLs, decay products*)


(* ::Input:: *)
(*nn=Length[\[Theta]\[Phi]Vals];*)
(*mass=0.02;*)
(*phasespace=PhaseSpacePerDecayChannel["HNL-mixing-mu",mass,"ee\[Nu]",nn,"True"];*)
(*(*\[Theta],\[Phi] for which HNLs would fly to the detector*)*)
(*angles=Take[\[Theta]\[Phi]Vals,{1,nn}];*)
(*(*HNL energies*)*)
(*prod="Fake \[Mu]";*)
(*energies=EnergySampling[prod,mass,nn];*)
(*momenta=Sqrt[energies^2-mass^2]*({Sin[angles[[All,1]]]Cos[angles[[All,2]]],Sin[angles[[All,1]]]Sin[angles[[All,2]]],Cos[angles[[All,1]]]}//Transpose);*)
(*daughtermomenta=boosting[energies,momenta,phasespace,mass];*)
(*Histogram[{daughtermomenta[[All,indexE1]],daughtermomenta[[All,indexE1+indexm1]],daughtermomenta[[All,indexE1]]+daughtermomenta[[All,indexE1+indexm1]]}]*)
(**)


(* ::Subsubsection::Closed:: *)
(*Smearing*)


(* ::Input:: *)
(*\[Alpha]Vals=\[Alpha]Smearing[daughtermomenta];*)
(*Histogram[{\[Alpha]Vals[[All,1]],\[Alpha]Vals[[All,2]],\[Alpha]Vals[[All,3]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\[Alpha] [rad]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"Unsmeared","Smeared \[Alpha]","Smeared \!\(\*SubscriptBox[\(\[Theta]\), \(1, 2\)]\)"},{0.2,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]]*)
(*weights=1/Sqrt[energies^2-mass^2](*Sin[angles[[All,1]]]/(Abs[Cos[angles[[All,1]]]]Sqrt[energies^2-mass^2])*)(*Table[1.,Length[angles]]*);*)
(*finaldata=Join[daughtermomenta,Partition[weights,1],\[Alpha]Vals,2];*)
(*{selection[finaldata,0.017,15*Pi/180.,3],selection[finaldata,0.017,15*Pi/180.,2],selection[finaldata,0.017,15*Pi/180.,1],*)
(*selection[finaldata,0.017,0.,3]}*)
(*{selection[finaldata,0.01,15*Pi/180.,3],selection[finaldata,0.01,15*Pi/180.,2],selection[finaldata,0.01,15*Pi/180.,1],*)
(*selection[finaldata,0.01,0.,3]}*)


(* ::Subsubsection::Closed:: *)
(*Comparing with Soleti*)


(* ::Input:: *)
(*phasespaceSoleti={#[[2]],#[[3]],#[[4]],#[[1]],0.5*10^-3,#[[4+2]],#[[4+3]],#[[4+4]],#[[4+1]],0.5*10^-3}&/@Import[FileNameJoin[{"temp1/shiness/phasespace_0.02.txt"}],"Table"];*)


(* ::Input:: *)
(*pt1=Histogram[{daughtermomenta[[All,indexE1]],phasespaceSoleti[[All,indexE1]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(e1\)]\) [GeV]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"SensCalc","Roberto"},{0.8,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]];*)
(*pt2=Histogram[{daughtermomenta[[All,indexm1+indexE1]],phasespaceSoleti[[All,indexm1+indexE1]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(e2\)]\) [GeV]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"SensCalc","Roberto"},{0.8,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]];*)
(*pt3=Histogram[{daughtermomenta[[All,indexE1]]+daughtermomenta[[All,indexm1+indexE1]],phasespaceSoleti[[All,indexm1+indexE1]]+phasespaceSoleti[[All,indexE1]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(e1\)]\)+\!\(\*SubscriptBox[\(E\), \(e2\)]\) [GeV]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"SensCalc","Roberto"},{0.15,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]];*)
(*Style[Row[{pt1,pt2,pt3}],ImageSizeMultipliers->{1, 1,1}]*)
(**)
(**)


(* ::Subsection::Closed:: *)
(*Final state multiplicity*)


(* ::Input:: *)
(*(*(*Multiplicity per given particle*)*)
(*mtp[mt_]:=Switch[mt,111.,2,310.,2,221.,(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),113.,2,213.,3,331.,2+(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),223.,4,12.,0.,-12.,0,14.,0,-14.,0,16.,0,-16.,0,_,1]*)
(*mtpNoECAL[mt_]:=Switch[mt,111.,2,310.,2,221.,(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),113.,2,213.,3,331.,2+(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),223.,4,12.,0.,-12.,0,14.,0,-14.,0,16.,0,-16.,0,22.,0,130.,0,_,1]*)
(*mtp[210.]*)
(*listphasespaces[LLP_,mLLP_]:=Block[{},procslist=Table[{proc,ListBrRatios[LLP,mLLP,proc],If[ListBrRatios[LLP,mLLP,proc]>10^-3.,If[JetsPresence[LLP,proc]=="Yes",TakingHadronizedPhaseSpace[PhaseSpaceDecaysRestJets[LLP,proc,mLLP],30],{PhaseSpaceDecaysRest[LLP,proc,mLLP,30,"True"]}],{0}]},{proc,ProcessesList[LLP,"True"]}];*)
(*procslist=Select[procslist,#[[2]]>10^-3&];*)
(*multiplicity[i_]:=Module[{},*)
(*Do[*)
(*DATA[j]=procslist[[i]][[3]][[j]];*)
(*len[j]=Length[DATA[j]];*)
(*numparts=Length[DATA[j][[1]]]/8;*)
(*pdgpos=Table[8*(m-1)+6,{m,1,numparts,1}];*)
(*pdgs=DATA[j][[All,pdgpos]][[1]];*)
(*mtpval[j]=Sum[mtp[pdgs[[m]]],{m,1,Length[pdgs],1}];*)
(*mtpNoECALval[j]=Sum[mtpNoECAL[pdgs[[m]]],{m,1,Length[pdgs],1}];*)
(*,{j,1,Length[procslist[[i]][[3]]],1}];*)
(*{Sum[len[j]*mtpval[j],{j,1,Length[procslist[[i]][[3]]],1}]/Sum[len[j],{j,1,Length[procslist[[i]][[3]]],1}],Sum[len[j]*mtpNoECALval[j],{j,1,Length[procslist[[i]][[3]]],1}]/Sum[len[j],{j,1,Length[procslist[[i]][[3]]],1}]}*)
(*];*)
(*list=Sum[procslist[[i]][[2]]multiplicity[i],{i,1,Length[procslist],1}]/Sum[procslist[[i]][[2]],{i,1,Length[procslist],1}]*)
(*]*)
(*mulslist[LLP_]:=Block[{},*)
(*ttt2=Table[{mLLPlist[LLP][[k]],listphasespaces[LLP,mLLPlist[LLP][[k]]]},{k,1,Length[mLLPlist[LLP]],1}];*)
(*{Table[{ttt2[[i]][[1]],ttt2[[i]][[2]][[1]]},{i,1,Length[ttt2],1}],Table[{ttt2[[i]][[1]],ttt2[[i]][[2]][[2]]},{i,1,Length[ttt2],1}]}*)
(*]*)
(*fipsformult={"Scalar","HNL-mixing-e","ALP-gluon"};*)
(*multlist=Table[mulslist[LLP],{LLP,fipsformult}];*)
(*Show[ListPlot[{multlist[[1]][[1]],multlist[[1]][[2]],multlist[[2]][[1]],multlist[[2]][[2]],multlist[[3]][[1]],multlist[[3]][[2]]},Joined->True,PlotStyle->{{Thick,Blue},{Thick,Blue,Dashing[0.02]},{Thick,Darker@Red},{Thick,Darker@Red,Dashing[0.02]},{Thick,Darker@Darker@Green},{Thick,Darker@Darker@Green,Dashing[0.02]}},Frame\[Rule] True,FrameLabel\[Rule]{"Subscript[m, LLP] [GeV]" , "Subscript[n, per decay]"},FrameStyle\[Rule]Directive[Black, 23],ImageSize->Large,PlotRange\[Rule]{{0.05,4.5},{1,12}},PlotLabel\[Rule]Style[Row[{"Dashed: charged only. Solid: incl. \[Gamma],Subscript[K^0, L]"}],18,Black]],Plot[{0.9,0.9,0.9,0.9,0.9},{x,0,1},PlotStyle->{{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green}},PlotLegends\[Rule]Placed[Style[#,18]&/@fipsformult,{0.24,0.8}]]]*)*)


(* ::Subsection::Closed:: *)
(*In the limit Subscript[E, LLP]/Subscript[m, LLP] >> 1 and in absence of energy cut and magnetic field etc ., Subscript[\[Epsilon], decay] must tend to 1 for the LLPs pointing to the detector and to 0 for those that do not point to the detector*)


(* ::Input:: *)
(*(*mtest=1.9;*)
(*LLPtest="Scalar";*)
(*test1=FinalBlockMass[LLPtest,mtest,ProcessesListRefined[LLPtest,ECALoptionGivenExperiment],1000,"True",">=2"];//AbsoluteTiming*)
(*{TableAzDecayAcceptanceToDet[[All,5]]//Mean,Select[TableAzDecayAcceptanceToDet,#[[2]]>40&][[All,5]]//Mean,Select[TableAzDecayAcceptanceToDet,#[[2]]>40&&#[[4]]!=0&][[All,5]]//Mean}*)
(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",TableAzDecayAcceptanceNotToDet[[All,5]]//Mean]*)
(*hist1=Histogram[Select[TableAzDecayAcceptanceToDet,#[[2]]>50*mtest&&#[[4]]!=0&][[All,5]],100]*)
(*hist2=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Histogram[Select[TableAzDecayAcceptanceNotToDet,#[[2]]>10*mtest&&#[[4]]!=0&][[All,5]],100]]*)*)
